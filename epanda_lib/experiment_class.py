""" Experiment data class"""

# pylint: disable=invalid-name, line-too-long, import-outside-toplevel
import dataclasses
import json
from dataclasses import field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Optional

from pydantic import ConfigDict, RootModel, TypeAdapter
from pydantic.dataclasses import dataclass

from epanda_lib.wellplate import Well

from .config.config import SQL_DB_PATH
from .config.pin import CURRENT_PIN
from . import sql_utilities


class ExperimentResultsRecord:
    """
    A class for representing a single entry in a result table.
    The table has columns:
    id,
    experiment_id,
    result_type,
    result_value
    """

    def __init__(self, experiment_id: int, result_type: str, result_value: str):
        self.experiment_id = experiment_id
        self.result_type = result_type
        self.result_value = result_value

    def __str__(self):
        return f"Experiment ID: {self.experiment_id}, Result Type: {self.result_type}, Result Value: {self.result_value}"

    def __repr__(self):
        return f"ResultTableRecord({self.experiment_id}, {self.result_type}, {self.result_value})"

    def __eq__(self, other):
        return (
            self.experiment_id == other.experiment_id
            and self.result_type == other.result_type
            and self.result_value == other.result_value
        )

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash((self.experiment_id, self.result_type, self.result_value))

    def __iter__(self):
        yield self.experiment_id
        yield self.result_type
        yield self.result_value

    def __list__(self):
        return [self.experiment_id, self.result_type, self.result_value]


class ExperimentParameterRecord:
    """
    A class for representing a single entry in an experiment parameter table.
    The table has columns:
    id,
    experiment_id,
    parameter_type,
    parameter_value
    """

    def __init__(self, experiment_id: int, parameter_type: str, parameter_value: str):
        self.experiment_id = experiment_id
        self.parameter_type = parameter_type
        self.parameter_value = parameter_value

    def __str__(self):
        return f"Experiment ID: {self.experiment_id}, Parameter Type: {self.parameter_type}, Parameter Value: {self.parameter_value}"

    def __repr__(self):
        return f"ExperimentParameterRecord({self.experiment_id}, {self.parameter_type}, {self.parameter_value})"

    def __eq__(self, other):
        return (
            self.experiment_id == other.experiment_id
            and self.parameter_type == other.parameter_type
            and self.parameter_value == other.parameter_value
        )

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash((self.experiment_id, self.parameter_type, self.parameter_value))

    def __iter__(self):
        yield self.experiment_id
        yield self.parameter_type
        yield self.parameter_value

    def __list__(self):
        return [self.experiment_id, self.parameter_type, self.parameter_value]


class ExperimentStatus(str, Enum):
    """Define the possible statuses of an experiment"""

    NEW = "new"
    QUEUED = "queued"
    RUNNING = "running"
    OCPCHECK = "ocpcheck"
    DEPOSITING = "depositing"
    EDEPOSITING = "e_depositing"
    RINSING = "rinsing"
    ERINSING = "rinsing electrode"
    BASELINE = "baselining"
    CHARACTERIZING = "characterizing"
    CA = "cyclic-amperometry"
    CV = "cyclic-voltametry"
    FINAL_RINSE = "final_rinse"
    COMPLETE = "complete"
    ERROR = "error"
    MIXING = "mixing"
    IMAGING = "imaging"
    CLEARING = "clearing"
    FLUSHING = "flushing"
    PAUSED = "paused"


@dataclass(config=ConfigDict(validate_assignment=False))
class ExperimentResult:
    """Define the data that is generated by an experiment"""

    id: int = None
    well_id: str = None
    ocp_dep_files: list[Path] = field(default_factory=list)
    ocp_dep_passes: list[bool] = field(default_factory=list)
    ocp_char_files: list[Path] = field(default_factory=list)
    ocp_char_passes: list[bool] = field(default_factory=list)
    ocp_char_final_voltages: list[float] = field(default_factory=list)
    deposition_data_files: list[Path] = field(default_factory=list)
    deposition_plot_files: list[Path] = field(default_factory=list)
    deposition_max_values: list[float] = field(default_factory=list)
    depsotion_min_values: list[float] = field(default_factory=list)
    characterization_data_files: list[Path] = field(default_factory=list)
    characterization_plot_files: list[Path] = field(default_factory=list)
    characterization_max_values: list[float] = field(default_factory=list)
    characterization_min_values: list[float] = field(default_factory=list)
    pumping_record: list = None
    image_files: list[Path] = field(default_factory=list)

    def set_ocp_dep_file(self, file: Path, passed: bool, final_voltage: float):
        """Set the file, the pass/fail status, and the final voltage"""

        # Set the file, the pass/fail status, and the final voltage
        self.ocp_dep_files.append(file)
        self.ocp_dep_passes.append(passed)
        self.ocp_char_final_voltages.append(final_voltage)

        # to_insert = []
        # to_insert.append(sql_utilities.ResultTableEntry(self.id, "ocp_dep_file", str(file)))
        # to_insert.append(sql_utilities.ResultTableEntry(self.id, "ocp_dep_pass", str(passed)))
        # to_insert.append(sql_utilities.ResultTableEntry(self.id, "ocp_dep_final_voltage", str(final_voltage)))
        # sql_utilities.insert_result_table_entry

    def set_ocp_char_file(self, file: Path, passed: bool, final_voltage: float):
        """Set the file, the pass/fail status, and the final voltage"""
        self.ocp_char_files.append(file)
        self.ocp_char_passes.append(passed)
        self.ocp_char_final_voltages.append(final_voltage)

    def set_deposition_data_file(
        self,
        file: Path,
        plot_file: Path = None,
        max_value: float = None,
        min_value: float = None,
    ):
        """Set the file, the plot file, the max value, and the min value"""
        self.deposition_data_files.append(file)
        if plot_file is not None:
            self.deposition_plot_files.append(plot_file)
        if max_value is not None:
            self.deposition_max_values.append(max_value)
        if min_value is not None:
            self.depsotion_min_values.append(min_value)

    def set_characterization_data_file(
        self,
        file: Path,
        plot_file: Path = None,
        max_value: float = None,
        min_value: float = None,
    ):
        """Set the file, the plot file, the max value, and the min value"""
        self.characterization_data_files.append(file)
        if plot_file is not None:
            self.characterization_plot_files.append(plot_file)
        if max_value is not None:
            self.characterization_max_values.append(max_value)
        if min_value is not None:
            self.characterization_min_values.append(min_value)

    def set_pumping_record(self, record: list):
        """Set the pumping record"""
        self.pumping_record = record

    def append_image_file(self, file: Path):
        """Append the image file"""
        self.image_files.append(file)

    def __list__(self):
        """Return a list of key value pairs, this is not a dictionary because there are duplicate keys for some values"""
        return [
            ("ocp_dep_files", *self.ocp_dep_files),
            ("ocp_dep_passes", *self.ocp_dep_passes),
            ("ocp_char_files", *self.ocp_char_files),
            ("ocp_char_passes", *self.ocp_char_passes),
            ("ocp_char_final_voltages", *self.ocp_char_final_voltages),
            ("deposition_data_files", *self.deposition_data_files),
            ("deposition_plot_files", *self.deposition_plot_files),
            ("deposition_max_values", *self.deposition_max_values),
            ("depsotion_min_values", *self.depsotion_min_values),
            ("characterization_data_files", *self.characterization_data_files),
            ("characterization_plot_files", *self.characterization_plot_files),
            ("characterization_max_values", *self.characterization_max_values),
            ("characterization_min_values", *self.characterization_min_values),
            ("image_files", *self.image_files),
        ]

    def one_to_many(self):
        """Turn the results object into individual result table records"""
        return [
            ExperimentResultsRecord(self.id, key, value)
            for key, value in self.__list__()
        ]


@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentBase:
    """Define the common data used to run and define an experiment"""

    id: int = None
    experiment_name: str = None
    protocol_id: int = None
    priority: int = 0
    well_id: Optional[str] = None
    pin: str = None
    project_id: int = None
    solutions: dict = None
    solutions_corrected: dict = solutions
    well_type_number: int = (
        None  # is used to indicate the type of well the experiment should run in
    )
    pumping_rate: float = 0.3
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: str = None  # Optional[FilePath] = None
    results: Optional[ExperimentResult] = None
    project_campaign_id: int = None
    protocol_type: int = 1  # depreciated
    plate_id: Optional[int] = None
    override_well_selection: int = 0  # 0 is normal, 1 is override
    process_type: Optional[int] = (
        1  # 1 is 5mm_FeCN, 2 is 10mm_FeCN first, 3 is 10mm_FeCN second
    )
    jira_issue_key: Optional[str] = None
    experiment_type: int = 0
    well = None

    def set_status(self, new_status: ExperimentStatus) -> None:
        """Set the status of the experiment"""
        self.status = new_status
        self.status_date = datetime.now().isoformat(timespec="seconds")
        try:
            from .obs_controls import OBSController

            OBSController().place_experiment_on_screen(self)
        except Exception as e:
            print(f"Error sending status to OBS: {e}")
            # don't raise the error, just print it
    
    def set_status_and_save(self, new_status: ExperimentStatus) -> None:
        """Set the status and status date of the experiment"""
        self.status = new_status
        self.status_date = datetime.now().isoformat(timespec="seconds")
        if self.well:
            self.well.save_to_db()

        else:
            print("Well object not set. Saving to db via alternative method")
            sql_utilities.update_experiment_status(self)
        try:
            from .obs_controls import OBSController

            OBSController().place_experiment_on_screen(self)
        except Exception as e:
            print(f"Error sending status to OBS: {e}")
            # don't raise the error, just print it

    def is_same_id(self, other) -> bool:
        """Check if two experiments have the same id"""

        return self.id == other.id
    
    def is_same_well_id(self, other) -> bool:
        """Check if two experiments have the same well id"""

        return self.well_id == other.well_id
    
    ## other check if same methods

    def get_parameters(self) -> list[ExperimentParameterRecord]:
        """Turn the experiment object into a list of individual experiment parameter table records"""
        all_parameters = [
            ExperimentParameterRecord(self.id, parameter_type, parameter_value)
            for parameter_type, parameter_value in self.__dict__.items()
        ]

        # Remove project_id, project_campaign_id, well_type,protocol_id, pin, experiment_type, jira_issue_key, priority, process_type, filename, status, status_date, results, well
        all_parameters = [
            parameter
            for parameter in all_parameters
            if parameter.parameter_type
            not in [
                "project_id",
                "project_campaign_id",
                "well_type",
                "protocol_id",
                "pin",
                "experiment_type",
                "jira_issue_key",
                "priority",
                "process_type",
                "filename",
                "status",
                "status_date",
                "results",
                "well",
            ]
        ]

        return all_parameters

@dataclass(config=ConfigDict(validate_assignment=True))
class CorrectionFactorExperiment(ExperimentBase):
    """Define the data that is used to run an experiment"""

    project_id: int = 11
    correction_factor: float = 1.0


@dataclass(config=ConfigDict(validate_assignment=True))
class EchemExperimentBase(ExperimentBase):
    """
    Define the data that is used to run an experiment

    This is the base class for all echem experiments
    Attributes:
    ------------
    ocp: int
        Open Circuit Potential
    ca: int
        Cyclic Amperometry
    cv: int
        Cyclic Voltammetry
    baseline: int
        Baseline
    flush_sol_name: str
        Flush solution name
    flush_vol: int
        Flush solution volume
    mix = 1
        Binary mix or dont mix
    mix_count: int
        Number of times to mix
    mix_volume: int
        Volume to mix
    rinse_count: int
        Default rinse count
    rinse_vol: int
        Default rinse volume
    ca_sample_period: float
        Deposition sample period
    CAvi: float
        Pre-step voltage (V)
    CAti: float
        Pre-step delay time (s)
    CAv1: float
        Step 1 voltage (V), deposition potential (V)
    CAt1: float
        run time 300 seconds, deposition duration (s)
    CAv2: float
        Step 2 voltage (V)
    CAt2: float
        Step 2 time (s)
    CAsamplerate: float
        sample period (s)
    char_sol_name: str
        Characterization solution name
    char_vol: int
        Characterization solution volume
    cv_sample_period: float
        Characterization sample period
    cv_scan_rate: float
        Scan rate
    CVvi: float
        initial voltage
    CVap1: float
        first anodic peak
    CVap2: float
        second anodic peak
    CVvf: float
        final voltage
    CVstep: float
        step size
    CVsr1: float
        scan rate 1
    CVcycle: int
        number of cycles
    CVsr2: float
        CVsr1
    CVsr3: float
        CVsr1
    CVsamplerate: float
        CVstep / CVsr1

    """

    experiment_type: int = 1  # echem generic
    ocp: int = 1  # Open Circuit Potential
    ca: int = 1  # Cyclic Amperometry
    cv: int = 1  # Cyclic Voltammetry
    baseline: int = 0  # Baseline

    flush_sol_name: str = ""  # Flush solution name
    flush_vol: int = 0  # Flush solution volume

    mix = 0  # Binary mix or dont mix
    mix_count: int = 0  # Number of times to mix
    mix_volume: int = 0  # Volume to mix
    rinse_count: int = 4  # Default rinse count
    rinse_vol: int = 120  # Default rinse volume

    ca_sample_period: float = 0.1  # Deposition sample period
    ca_prestep_voltage: float = 0.0  # Pre-step voltage (V)
    # CAvi = ca_prestep_voltage
    ca_prestep_time_delay: float = 0.0  # Pre-step delay time (s)
    # CAti = ca_prestep_time_delay
    ca_step_1_voltage: float = -1.7  # Step 1 voltage (V), deposition potential (V)
    # CAv1 = ca_step_1_voltage
    ca_step_1_time: float = 300.0  # run time 300 seconds, deposition duration (s)
    # CAt1 = ca_step_1_time
    ca_step_2_voltage: float = 0.0  # Step 2 voltage (V)
    # CAv2 = ca_step_2_voltage
    ca_step_2_time: float = 0.0  # Step 2 time (s)
    # CAt2 = ca_step_2_time
    ca_sample_rate: float = 0.5  # sample period (s)
    # CAsamplerate = ca_sample_rate

    char_sol_name: str = ""  # Characterization solution name
    char_vol: int = 0  # Characterization solution volume
    cv_sample_period: float = 0.1  # Characterization sample period
    cv_initial_voltage: float = 0.0  # initial voltage
    cv_first_anodic_peak: float = 0.5  # first anodic peak
    cv_second_anodic_peak: float = -0.2  # second anodic peak
    cv_final_voltage: float = 0.0  # final voltage
    cv_step_size: float = 0.01  # step size
    cv_cycle_count: int = 3  # number of cycles
    cv_scan_rate_cycle_1: float = 0.1
    cv_scan_rate_cycle_2: float = 0.1
    cv_scan_rate_cycle_3: float = 0.1

    # CVvi: float = 0.0  # initial voltage
    # CVap1: float = 0.5  # first anodic peak
    # CVap2: float = -0.2 # second anodic peak
    # CVvf: float = 0.0  # final voltage
    # CVstep: float = 0.01 # step size
    # CVsr1: float = 0.1 # scan rate 1
    # CVcycle: int = 3 # number of cycles
    # CVsr2: float = CVsr1
    # CVsr3: float = CVsr1

    @property
    def cv_sample_rate(self):
        """CVstep / CVsr1"""
        return round(self.cv_step_size / self.cv_scan_rate_cycle_1, 4)

    def print_ca_parameters(self) -> str:
        """Print the CA parameters"""
        if self.ca:
            return f"""
        CA Parameters
            Pre-step Voltage: {self.ca_prestep_voltage}
            Pre-step Time Delay: {self.ca_prestep_time_delay}
            Step 1 Voltage: {self.ca_step_1_voltage}
            Step 1 Time: {self.ca_step_1_time}
            Step 2 Voltage: {self.ca_step_2_voltage}
            Step 2 Time: {self.ca_step_2_time}
            CA Sample Rate: {self.ca_sample_rate}
    """
        else:
            return """
        CA Not selected
    """

    def print_cv_parameters(self) -> str:
        """Print the CV parameters"""
        if self.cv:
            return f"""
        CV Parameters
            CV: {bool(self.cv)}
            CV Baseline: {bool(self.baseline)}
            Sample Period: {self.cv_sample_period}
            Initial Voltage (CVvi): {self.cv_initial_voltage}
            First Anodic Peak (CVap1): {self.cv_first_anodic_peak}
            Second Anodic Peak (CVap2): {self.cv_second_anodic_peak}
            Final Voltage (CVvf): {self.cv_final_voltage}
            Step Size (CVstep): {self.cv_step_size}
            Cycle Count: {self.cv_cycle_count}
            Scan Rate Cycle 1 (CVsr1): {self.cv_scan_rate_cycle_1}
            Scan Rate Cycle 2 (CVsr2): {self.cv_scan_rate_cycle_2}
            Scan Rate Cycle 3 (CVsr3): {self.cv_scan_rate_cycle_3}
            CV Sample Rate: {self.cv_sample_rate}
    """
        else:
            return """
        CV not selected
"""

    def print_all_experiment_parameters(self) -> str:
        """Print the experiment parameters"""
        return f"""
{self.experiment_name} 
        Plate #: {self.plate_id}
        Experiment ID: {self.id}
        Well ID: {self.well_id}
        Status: {self.status.value}
        Priority: {self.priority}
        Solutions: {self.solutions}
        Corrected Solutions: {self.solutions_corrected}
        Filename: {self.filename}

        Echem Parameters
            Run Open Circuit Potential: {bool(self.ocp)}
            Run Cyclic Amperometry: {bool(self.ca)}
            Run Cyclic Voltammetry: {bool(self.cv)}
            Run CV Baseline: {bool(self.baseline)}
            Flush Solution Name: {self.flush_sol_name}
            Flush Solution Volume: {self.flush_vol}
            Mix: {bool(self.mix)}
            Mix Count: {self.mix_count}
            Mix Volume: {self.mix_volume}
            Rinse Count: {self.rinse_count}
            Rinse Volume: {self.rinse_vol}

        {self.print_ca_parameters()}

        {self.print_cv_parameters()}
    """


@dataclass(config=ConfigDict(validate_assignment=True))
class EchemExperimentParameters:
    """
    Define the data that is used to run an experiment

    This is the base class for all echem experiments
    Attributes:
    ------------
    ocp: int
        Open Circuit Potential
    ca: int
        Cyclic Amperometry
    cv: int
        Cyclic Voltammetry
    baseline: int
        Baseline
    flush_sol_name: str
        Flush solution name
    flush_vol: int
        Flush solution volume
    mix = 1
        Binary mix or dont mix
    mix_count: int
        Number of times to mix
    mix_volume: int
        Volume to mix
    rinse_count: int
        Default rinse count
    rinse_vol: int
        Default rinse volume
    ca_sample_period: float
        Deposition sample period
    CAvi: float
        Pre-step voltage (V)
    CAti: float
        Pre-step delay time (s)
    CAv1: float
        Step 1 voltage (V), deposition potential (V)
    CAt1: float
        run time 300 seconds, deposition duration (s)
    CAv2: float
        Step 2 voltage (V)
    CAt2: float
        Step 2 time (s)
    CAsamplerate: float
        sample period (s)
    char_sol_name: str
        Characterization solution name
    char_vol: int
        Characterization solution volume
    cv_sample_period: float
        Characterization sample period
    cv_scan_rate: float
        Scan rate
    CVvi: float
        initial voltage
    CVap1: float
        first anodic peak
    CVap2: float
        second anodic peak
    CVvf: float
        final voltage
    CVstep: float
        step size
    CVsr1: float
        scan rate 1
    CVcycle: int
        number of cycles
    CVsr2: float
        CVsr1
    CVsr3: float
        CVsr1
    CVsamplerate: float
        CVstep / CVsr1

    """

    ocp: int = 1  # Open Circuit Potential
    ca: int = 1  # Cyclic Amperometry
    cv: int = 1  # Cyclic Voltammetry
    baseline: int = 0  # Baseline

    flush_sol_name: str = ""  # Flush solution name
    flush_vol: int = 0  # Flush solution volume

    mix = 0  # Binary mix or dont mix
    mix_count: int = 0  # Number of times to mix
    mix_volume: int = 0  # Volume to mix
    rinse_count: int = 4  # Default rinse count
    rinse_vol: int = 120  # Default rinse volume

    ca_sample_period: float = 0.1  # Deposition sample period
    ca_prestep_voltage: float = 0.0  # Pre-step voltage (V)
    # CAvi = ca_prestep_voltage
    ca_prestep_time_delay: float = 0.0  # Pre-step delay time (s)
    # CAti = ca_prestep_time_delay
    ca_step_1_voltage: float = -1.7  # Step 1 voltage (V), deposition potential (V)
    # CAv1 = ca_step_1_voltage
    ca_step_1_time: float = 300.0  # run time 300 seconds, deposition duration (s)
    # CAt1 = ca_step_1_time
    ca_step_2_voltage: float = 0.0  # Step 2 voltage (V)
    # CAv2 = ca_step_2_voltage
    ca_step_2_time: float = 0.0  # Step 2 time (s)
    # CAt2 = ca_step_2_time
    ca_sample_rate: float = 0.5  # sample period (s)
    # CAsamplerate = ca_sample_rate

    char_sol_name: str = ""  # Characterization solution name
    char_vol: int = 0  # Characterization solution volume
    cv_sample_period: float = 0.1  # Characterization sample period
    cv_initial_voltage: float = 0.0  # initial voltage
    cv_first_anodic_peak: float = 0.5  # first anodic peak
    cv_second_anodic_peak: float = -0.2  # second anodic peak
    cv_final_voltage: float = 0.0  # final voltage
    cv_step_size: float = 0.01  # step size
    cv_cycle_count: int = 3  # number of cycles
    cv_scan_rate_cycle_1: float = 0.1
    cv_scan_rate_cycle_2: float = 0.1
    cv_scan_rate_cycle_3: float = 0.1

    # The below properies and setters are to allow for legacy ways of referencing the properties
    @property
    def CVvi(self):
        """Alias for cv_initial_voltage"""
        return self.cv_initial_voltage

    @CVvi.setter
    def CVvi(self, value):
        """Alias for cv_initial_voltage"""
        self.cv_initial_voltage = value

    @property
    def CVap1(self):
        """Alias for cv_first_anodic_peak"""
        return self.cv_first_anodic_peak

    @CVap1.setter
    def CVap1(self, value):
        """Alias for cv_first_anodic_peak"""
        self.cv_first_anodic_peak = value

    @property
    def CVap2(self):
        """Alias for cv_second_anodic_peak"""
        return self.cv_second_anodic_peak

    @CVap2.setter
    def CVap2(self, value):
        """Alias for cv_second_anodic_peak"""
        self.cv_second_anodic_peak = value

    @property
    def CVvf(self):
        """Alias for cv_final_voltage"""
        return self.cv_final_voltage

    @CVvf.setter
    def CVvf(self, value):
        """Alias for cv_final_voltage"""
        self.cv_final_voltage = value

    @property
    def CVstep(self):
        """Alias for cv_step_size"""
        return self.cv_step_size

    @CVstep.setter
    def CVstep(self, value):
        """Alias for cv_step_size"""
        self.cv_step_size = value

    @property
    def CVsr1(self):
        """Alias for cv_scan_rate_cycle_1"""
        return self.cv_scan_rate_cycle_1

    @CVsr1.setter
    def CVsr1(self, value):
        """Alias for cv_scan_rate_cycle_1"""
        self.cv_scan_rate_cycle_1 = value

    @property
    def CVsr2(self):
        """Alias for cv_scan_rate_cycle_2"""
        return self.cv_scan_rate_cycle_2

    @CVsr2.setter
    def CVsr2(self, value):
        """Alias for cv_scan_rate_cycle_2"""
        self.cv_scan_rate_cycle_2 = value

    @property
    def CVsr3(self):
        """Alias for cv_scan_rate_cycle_3"""
        return self.cv_scan_rate_cycle_3

    @CVsr3.setter
    def CVsr3(self, value):
        """Alias for cv_scan_rate_cycle_3"""
        self.cv_scan_rate_cycle_3 = value

    # CVvi: float = 0.0  # initial voltage
    # CVap1: float = 0.5  # first anodic peak
    # CVap2: float = -0.2 # second anodic peak
    # CVvf: float = 0.0  # final voltage
    # CVstep: float = 0.01 # step size
    # CVsr1: float = 0.1 # scan rate 1
    # CVcycle: int = 3 # number of cycles
    # CVsr2: float = CVsr1
    # CVsr3: float = CVsr1

    @property
    def cv_sample_rate(self):
        """CVstep / CVsr1"""
        return round(self.cv_step_size / self.cv_scan_rate_cycle_1, 4)

    def print_ca_parameters(self):
        """Print the CA parameters"""
        if self.ca:
            return f"""
        CA Parameters
            Pre-step Voltage: {self.ca_prestep_voltage}
            Pre-step Time Delay: {self.ca_prestep_time_delay}
            Step 1 Voltage: {self.ca_step_1_voltage}
            Step 1 Time: {self.ca_step_1_time}
            Step 2 Voltage: {self.ca_step_2_voltage}
            Step 2 Time: {self.ca_step_2_time}
            CA Sample Rate: {self.ca_sample_rate}
    """
        else:
            return """
        CA Not selected
    """

    def print_cv_parameters(self):
        """Print the CV parameters"""
        if self.cv:
            return f"""
        CV Parameters
            CV: {bool(self.cv)}
            CV Baseline: {bool(self.baseline)}
            Sample Period: {self.cv_sample_period}
            Initial Voltage (CVvi): {self.cv_initial_voltage}
            First Anodic Peak (CVap1): {self.cv_first_anodic_peak}
            Second Anodic Peak (CVap2): {self.cv_second_anodic_peak}
            Final Voltage (CVvf): {self.cv_final_voltage}
            Step Size (CVstep): {self.cv_step_size}
            Cycle Count: {self.cv_cycle_count}
            Scan Rate Cycle 1 (CVsr1): {self.cv_scan_rate_cycle_1}
            Scan Rate Cycle 2 (CVsr2): {self.cv_scan_rate_cycle_2}
            Scan Rate Cycle 3 (CVsr3): {self.cv_scan_rate_cycle_3}
            CV Sample Rate: {self.cv_sample_rate}
    """
        else:
            return """
        CV not selected
"""


# @dataclass(config=ConfigDict(validate_assignment=True))
# class EdotExperiment(ExperimentBase):
#     """Define the data that is used to run an edot experiment"""

#     project_id: int = 16
#     well_type_number: int = 4  # ito
#     experiment_type: int = 2  # edot

#     # pdot deposition - parameters for the deposition part of the experiment
#     pdot_deposition: EchemExperimentParameters = None
#     # pdot bleaching
#     pdot_bleaching: EchemExperimentParameters = None
#     # pdot coloring
#     pdot_coloring: EchemExperimentParameters = None
#     # pdot characterization
#     pdot_characterization: EchemExperimentParameters = None

#     def print_all_experiment_parameters(self):
#         """Print the experiment parameters"""
#         return f"""
# {self.experiment_name}
#         Plate #: {self.plate_id}
#         Experiment ID: {self.id}
#         Well ID: {self.well_id}
#         Status: {self.status.value}
#         Priority: {self.priority}
#         Solutions: {self.solutions}
#         Corrected Solutions: {self.solutions_corrected}
#         Filename: {self.filename}

#         Deposition Parameters:
#             {self.pdot_deposition.print_ca_parameters()}
#             {self.pdot_deposition.print_cv_parameters()}

#         Bleaching Parameters:
#             {self.pdot_bleaching.print_ca_parameters()}
#             {self.pdot_bleaching.print_cv_parameters()}

#         Coloring Parameters:
#             {self.pdot_coloring.print_ca_parameters()}
#             {self.pdot_coloring.print_cv_parameters()}

#         Characterization Parameters:
#             {self.pdot_characterization.print_ca_parameters()}
#             {self.pdot_characterization.print_cv_parameters()}

#     """


def make_test_base_value() -> ExperimentBase:
    """Create a test experiment value for the class"""
    return ExperimentBase(
        id=0,
        experiment_name="test",
        priority=2,
        well_id="D5",
        pin=100099000999,
        project_id=3,
        solutions={"dmf": 0, "peg": 145, "acrylate": 145, "ferrocene": 0, "custom": 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().isoformat(timespec="seconds"),
        filename=f"test_{0}.json",
        results=None,
    )


def make_test_value() -> ExperimentBase:
    """Create a test experiment value for the class"""
    return ExperimentBase(
        id=0,
        experiment_name="test",
        priority=2,
        well_id="D5",
        pin=CURRENT_PIN,
        project_id=3,
        solutions={"dmf": 0, "peg": 145, "acrylate": 145, "ferrocene": 0, "custom": 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().isoformat(timespec="seconds"),
        filename=f"test_{0}.json",
        results=None,
    )


def parse_experiment(json_string: str) -> ExperimentBase:
    """Parse an experiment from a json string"""
    if isinstance(json_string, str):
        parsed_json = json.loads(json_string)
        if "ocp" in parsed_json:
            return RootModel[EchemExperimentBase].model_validate_json(json_string).root
    return RootModel[ExperimentBase].model_validate_json(json_string).root


# def serialize_experiment(experiment: (Experiment,ExperimentBase)) -> str:
#     '''Serialize an experiment to a json string'''
#     if isinstance(experiment, Experiment):
#         return RootModel[Experiment](experiment).model_dump_json(indent=4)


def serialize_experiment(experiment: tuple[ExperimentBase, EchemExperimentBase]) -> str:
    """Given an experiment, determine the type and then pass back the serialized json form"""

    if isinstance(experiment, EchemExperimentBase):
        return RootModel[EchemExperimentBase](experiment).model_dump_json(indent=4)
    if isinstance(experiment, ExperimentBase):
        return RootModel[ExperimentBase](experiment).model_dump_json(indent=4)
    return None


def parse_results(json_string: str) -> ExperimentResult:
    """Parse an experiment result from a json string"""
    return RootModel[ExperimentResult].model_validate_json(json_string).root


def serialize_results(results: ExperimentResult) -> str:
    """Serialize an experiment result to a json string"""
    return RootModel[ExperimentResult](results).model_dump_json(indent=4)


def test_parse():
    """Test that the class can be parsed from json and back"""
    value = make_test_value()
    print(f"Original---> {value}")
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    parsed_value = RootModel[ExperimentBase].model_validate_json(sample_json).root
    print(f"Parsed--->{parsed_value}")
    assert value == parsed_value


def test_serialize_experiment():
    """Test that the class can be serialized to json"""
    value = make_test_value()
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    print(sample_json)
    with open("temp_test_file.json", "w", encoding="UTF-8") as f:
        f.write(sample_json)


def test_serialize_experimentbase():
    """Test that the class can be serialized to json"""
    value = make_test_base_value()
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    print(sample_json)
    with open("temp_test_file.json", "w", encoding="UTF-8") as f:
        f.write(sample_json)


# def test_serialize_layered_experiment():
#     '''Test that the class can be serialized to json'''
#     value = make_test_layered_value()
#     sample_json = RootModel[LayeredExperiments](value).model_dump_json(indent=4)
#     print(sample_json)
#     with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
#         f.write(sample_json)


def test_serialize_results():
    """Test that the class can be serialized to json"""
    value = ExperimentResult(
        id=0,
        well_id="D5",
        ocp_dep_files=["ocp_dep_file"],
        ocp_dep_passes=[True],
        ocp_char_files=["ocp_char_file"],
        ocp_char_passes=[True],
        deposition_data_files=["deposition_data_file"],
        deposition_plot_files=["deposition_plot_file"],
        deposition_max_values=[0.0],
        depsotion_min_values=[0.0],
        characterization_data_files=["characterization_data_file"],
        characterization_plot_files=["characterization_plot_file"],
        characterization_max_values=[0.0],
        characterization_min_values=[0.0],
    )
    sample_json = RootModel[ExperimentResult](value).model_dump_json(indent=4)
    print(sample_json)
    with open("temp_test_file.json", "w", encoding="UTF-8") as f:
        f.write(sample_json)


def test_schema():
    """Test that the class can generate a json schema"""
    # Useful if you have tools that validate your json externally
    print(json.dumps(TypeAdapter(ExperimentBase).json_schema(), indent=4))


experiment_classes = {
    1: EchemExperimentBase,
    2: CorrectionFactorExperiment,
    # Add more mappings as needed
}


def get_experiment_class_by_id(experiment_id: int):
    return experiment_classes.get(experiment_id, ExperimentBase)


if __name__ == "__main__":
    test_serialize_experimentbase()
    test_parse()
    test_schema()
