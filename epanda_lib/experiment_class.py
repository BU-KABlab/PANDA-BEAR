""" Experiment data class"""

import json
from dataclasses import field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Optional

from pydantic import ConfigDict, RootModel, TypeAdapter
from pydantic.dataclasses import dataclass

from .config.config import SQL_DB_PATH
from .config.pin import CURRENT_PIN
from . import sql_utilities

class ExperimentStatus(str, Enum):
    """Define the possible statuses of an experiment"""

    NEW = "new"
    QUEUED = "queued"
    RUNNING = "running"
    OCPCHECK = "ocpcheck"
    DEPOSITING = "depositing"
    EDEPOSITING = "e_depositing"
    RINSING = "rinsing"
    ERINSING = "rinsing electrode"
    BASELINE = "baselining"
    CHARACTERIZING = "characterizing"
    CA = "cyclic-amperometry"
    CV = "cyclic-voltametry"
    FINAL_RINSE = "final_rinse"
    COMPLETE = "complete"
    ERROR = "error"
    MIXING = "mixing"
    IMAGING = "imaging"
    CLEARING = "clearing"
    FLUSHING = "flushing"


@dataclass(config=ConfigDict(validate_assignment=False))
class ExperimentResult:
    """Define the data that is generated by an experiment"""

    id: int = None
    well_id: str = None
    ocp_dep_files: list[Path] = field(default_factory=list)
    ocp_dep_passes: list[bool] = field(default_factory=list)
    ocp_char_files: list[Path] = field(default_factory=list)
    ocp_char_passes: list[bool] = field(default_factory=list)
    ocp_char_final_voltages: list[float] = field(default_factory=list)
    deposition_data_files: list[Path] = field(default_factory=list)
    deposition_plot_files: list[Path] = field(default_factory=list)
    deposition_max_values: list[float] = field(default_factory=list)
    depsotion_min_values: list[float] = field(default_factory=list)
    characterization_data_files: list[Path] = field(default_factory=list)
    characterization_plot_files: list[Path] = field(default_factory=list)
    characterization_max_values: list[float] = field(default_factory=list)
    characterization_min_values: list[float] = field(default_factory=list)
    pumping_record: list = None
    image_files: list[Path] = field(default_factory=list)

    def set_ocp_dep_file(self, file: Path, passed: bool, final_voltage: float):
        
        # Set the file, the pass/fail status, and the final voltage
        self.ocp_dep_files.append(file)
        self.ocp_dep_passes.append(passed)
        self.ocp_char_final_voltages.append(final_voltage)

        # results_to_insert = []
        # results_to_insert.append(sql_utilities.ResultTableEntry(self.id, "ocp_dep_file", str(file)))
        # results_to_insert.append(sql_utilities.ResultTableEntry(self.id, "ocp_dep_pass", str(passed)))
        # results_to_insert.append(sql_utilities.ResultTableEntry(self.id, "ocp_dep_final_voltage", str(final_voltage)))
        # sql_utilities.insert_result_table_entry


    def set_ocp_char_file(self, file: Path, passed: bool, final_voltage: float):
        self.ocp_char_files.append(file)
        self.ocp_char_passes.append(passed)
        self.ocp_char_final_voltages.append(final_voltage)

    def set_deposition_data_file(self, file: Path, plot_file: Path = None, max_value: float = None, min_value: float = None):
        self.deposition_data_files.append(file)
        if plot_file is not None:
            self.deposition_plot_files.append(plot_file)
        if max_value is not None:
            self.deposition_max_values.append(max_value)
        if min_value is not None:
            self.depsotion_min_values.append(min_value)

    def set_characterization_data_file(self, file: Path, plot_file: Path = None, max_value: float = None, min_value: float = None):
        self.characterization_data_files.append(file)
        if plot_file is not None:
            self.characterization_plot_files.append(plot_file)
        if max_value is not None:
            self.characterization_max_values.append(max_value)
        if min_value is not None:
            self.characterization_min_values.append(min_value)

    def set_pumping_record(self, record: list):
        self.pumping_record = record

    def set_image_file(self, file: Path):
        self.image_files.append(file)
    


@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentBase:
    """Define the common data used to run and define an experiment"""

    id: int = None
    experiment_name: str = None
    protocol_id: int = None
    priority: int = None
    well_id: Optional[str] = None
    pin: int = None
    project_id: int = None
    solutions: dict = None
    solutions_corrected: dict = None
    well_type_number: int = 1
    pumping_rate: float = 0.3
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: str = None  # Optional[FilePath] = None
    results: Optional[ExperimentResult] = None
    project_campaign_id: int = None
    protocol_type: int = 1  # 1 is 1 experiment at a time, 2 is layered
    plate_id: Optional[int] = None
    override_well_selection: int = 0  # 0 is normal, 1 is override
    process_type: Optional[int] = (
        1  # 1 is 5mm_FeCN, 2 is 10mm_FeCN first, 3 is 10mm_FeCN second
    )
    jira_issue_key: Optional[str] = None

    def set_status(self, new_status: ExperimentStatus):
        """Set the status and status date of the experiment"""
        self.status = new_status
        self.status_date = datetime.now()
        try:
            from .obs_controls import OBSController

            OBSController().place_experiment_on_screen(self)
        except Exception as e:
            print(f"Error setting status: {e}")
            # don't raise the error, just log it

    # @property
    # def solutions_corrected(self):
    #     '''Calculate the corrected volume for each solution'''
    #     if self.solutions is not None:
    #         return {
    #             key: correction_factor(value, viscosity=None)
    #             for key, value in self.solutions.items()
    #         }
    #     return None

    def is_same_id(self, other):
        """Check if two experiments have the same id"""


@dataclass(config=ConfigDict(validate_assignment=True))
class CorrectionFactorExperiment(ExperimentBase):
    """Define the data that is used to run an experiment"""

    project_id: int = 11
    correction_factor: float = 1.0


@dataclass(config=ConfigDict(validate_assignment=True))
class EchemExperimentBase(ExperimentBase):
    """
    Define the data that is used to run an experiment

    This is the base class for all echem experiments
    Attributes:
    ------------
    ocp: int
        Open Circuit Potential
    ca: int
        Cyclic Amperometry
    cv: int
        Cyclic Voltammetry
    baseline: int
        Baseline
    flush_sol_name: str
        Flush solution name
    flush_vol: int
        Flush solution volume
    mix = 1
        Binary mix or dont mix
    mix_count: int
        Number of times to mix
    mix_volume: int
        Volume to mix
    rinse_count: int
        Default rinse count
    rinse_vol: int
        Default rinse volume
    ca_sample_period: float
        Deposition sample period
    CAvi: float
        Pre-step voltage (V)
    CAti: float
        Pre-step delay time (s)
    CAv1: float
        Step 1 voltage (V), deposition potential (V)
    CAt1: float
        run time 300 seconds, deposition duration (s)
    CAv2: float
        Step 2 voltage (V)
    CAt2: float
        Step 2 time (s)
    CAsamplerate: float
        sample period (s)
    char_sol_name: str
        Characterization solution name
    char_vol: int
        Characterization solution volume
    cv_sample_period: float
        Characterization sample period
    cv_scan_rate: float
        Scan rate
    CVvi: float
        initial voltage
    CVap1: float
        first anodic peak
    CVap2: float
        second anodic peak
    CVvf: float
        final voltage
    CVstep: float
        step size
    CVsr1: float
        scan rate 1
    CVcycle: int
        number of cycles
    CVsr2: float
        CVsr1
    CVsr3: float
        CVsr1
    CVsamplerate: float
        CVstep / CVsr1

    """

    ocp: int = 1  # Open Circuit Potential
    ca: int = 1  # Cyclic Amperometry
    cv: int = 1  # Cyclic Voltammetry
    baseline: int = 0  # Baseline

    flush_sol_name: str = ""  # Flush solution name
    flush_vol: int = 0  # Flush solution volume

    mix = 0  # Binary mix or dont mix
    mix_count: int = 0  # Number of times to mix
    mix_volume: int = 0  # Volume to mix
    rinse_count: int = 4  # Default rinse count
    rinse_vol: int = 120  # Default rinse volume

    ca_sample_period: float = 0.1  # Deposition sample period
    ca_prestep_voltage: float = 0.0  # Pre-step voltage (V)
    # CAvi = ca_prestep_voltage
    ca_prestep_time_delay: float = 0.0  # Pre-step delay time (s)
    # CAti = ca_prestep_time_delay
    ca_step_1_voltage: float = -1.7  # Step 1 voltage (V), deposition potential (V)
    # CAv1 = ca_step_1_voltage
    ca_step_1_time: float = 300.0  # run time 300 seconds, deposition duration (s)
    # CAt1 = ca_step_1_time
    ca_step_2_voltage: float = 0.0  # Step 2 voltage (V)
    # CAv2 = ca_step_2_voltage
    ca_step_2_time: float = 0.0  # Step 2 time (s)
    # CAt2 = ca_step_2_time
    ca_sample_rate: float = 0.5  # sample period (s)
    # CAsamplerate = ca_sample_rate

    char_sol_name: str = ""  # Characterization solution name
    char_vol: int = 0  # Characterization solution volume
    cv_sample_period: float = 0.1  # Characterization sample period
    cv_initial_voltage: float = 0.0  # initial voltage
    cv_first_anodic_peak: float = 0.5  # first anodic peak
    cv_second_anodic_peak: float = -0.2  # second anodic peak
    cv_final_voltage: float = 0.0  # final voltage
    cv_step_size: float = 0.01  # step size
    cv_cycle_count: int = 3  # number of cycles
    cv_scan_rate_cycle_1: float = 0.1
    cv_scan_rate_cycle_2: float = 0.1
    cv_scan_rate_cycle_3: float = 0.1

    # CVvi: float = 0.0  # initial voltage
    # CVap1: float = 0.5  # first anodic peak
    # CVap2: float = -0.2 # second anodic peak
    # CVvf: float = 0.0  # final voltage
    # CVstep: float = 0.01 # step size
    # CVsr1: float = 0.1 # scan rate 1
    # CVcycle: int = 3 # number of cycles
    # CVsr2: float = CVsr1
    # CVsr3: float = CVsr1

    @property
    def cv_sample_rate(self):
        """CVstep / CVsr1"""
        return round(self.cv_step_size / self.cv_scan_rate_cycle_1, 4)

    def print_ca_parameters(self):
        """Print the CA parameters"""
        if self.ca:
            return f"""
        CA Parameters
            Pre-step Voltage: {self.ca_prestep_voltage}
            Pre-step Time Delay: {self.ca_prestep_time_delay}
            Step 1 Voltage: {self.ca_step_1_voltage}
            Step 1 Time: {self.ca_step_1_time}
            Step 2 Voltage: {self.ca_step_2_voltage}
            Step 2 Time: {self.ca_step_2_time}
            CA Sample Rate: {self.ca_sample_rate}
    """
        else:
            return """
        CA Not selected
    """

    def print_cv_parameters(self):
        """Print the CV parameters"""
        if self.cv:
            return f"""
        CV Parameters
            CV: {bool(self.cv)}
            CV Baseline: {bool(self.baseline)}
            Sample Period: {self.cv_sample_period}
            Initial Voltage (CVvi): {self.cv_initial_voltage}
            First Anodic Peak (CVap1): {self.cv_first_anodic_peak}
            Second Anodic Peak (CVap2): {self.cv_second_anodic_peak}
            Final Voltage (CVvf): {self.cv_final_voltage}
            Step Size (CVstep): {self.cv_step_size}
            Cycle Count: {self.cv_cycle_count}
            Scan Rate Cycle 1 (CVsr1): {self.cv_scan_rate_cycle_1}
            Scan Rate Cycle 2 (CVsr2): {self.cv_scan_rate_cycle_2}
            Scan Rate Cycle 3 (CVsr3): {self.cv_scan_rate_cycle_3}
            CV Sample Rate: {self.cv_sample_rate}
    """
        else:
            return """
        CV not selected
"""

    def print_all_experiment_parameters(self):
        """Print the experiment parameters"""
        return f"""
{self.experiment_name} 
        Plate #: {self.plate_id}
        Experiment ID: {self.id}
        Well ID: {self.well_id}
        Status: {self.status.value}
        Priority: {self.priority}
        Solutions: {self.solutions}
        Corrected Solutions: {self.solutions_corrected}
        Filename: {self.filename}

        Echem Parameters
            Run Open Circuit Potential: {bool(self.ocp)}
            Run Cyclic Amperometry: {bool(self.ca)}
            Run Cyclic Voltammetry: {bool(self.cv)}
            Run CV Baseline: {bool(self.baseline)}
            Flush Solution Name: {self.flush_sol_name}
            Flush Solution Volume: {self.flush_vol}
            Mix: {bool(self.mix)}
            Mix Count: {self.mix_count}
            Mix Volume: {self.mix_volume}
            Rinse Count: {self.rinse_count}
            Rinse Volume: {self.rinse_vol}

        {self.print_ca_parameters()}

        {self.print_cv_parameters()}
    """

@dataclass(config=ConfigDict(validate_assignment=True))
class EdotExperiment(EchemExperimentBase):
    """Define the data that is used to run an edot experiment"""
    project_id: int = 16

    #pdot deposition - parameters for the deposition part of the experiment

    #pdot bleaching

    #pdot coloring


def make_test_base_value() -> ExperimentBase:
    """Create a test experiment value for the class"""
    return ExperimentBase(
        id=0,
        experiment_name="test",
        priority=2,
        well_id="D5",
        pin= 100099000999,
        project_id=3,
        solutions={"dmf": 0, "peg": 145, "acrylate": 145, "ferrocene": 0, "custom": 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        filename=f"test_{0}.json",
        results=None,
    )


# def make_test_value() -> Experiment:
#     '''Create a test experiment value for the class'''
#     return Experiment(
#         id=0,
#         priority=2,
#         pin=1001001001001001,
#         target_well="D5",
#         dmf=0,
#         peg=145,
#         acrylate=145,
#         ferrocene=0,
#         custom=0,
#         ocp=1,
#         ca=1,
#         cv=1,
#         baseline = 0,
#         dep_duration=300,
#         dep_pot=-2.7,
#         ca_sample_period=0.01,
#         cv_sample_period=0.01,
#         cv_scan_rate = 0.05,
#         status=ExperimentStatus.QUEUED,
#         status_date=datetime.now(),
#         pumping_rate=0.5,
#         char_sol_name="ferrocene",
#         char_vol=290,
#         flush_sol_name="dmf",
#         flush_vol=120,
#         rinse_count=3,
#         rinse_vol=150,
#         mix = 1,
#         mix_count = 3,
#         mix_vol = 200,
#         mix_rate = 0.62,
#         filename= f"test_{datetime.now}.json",
#         results=None)

# def make_baseline_value() -> Experiment:
#     '''Create a test experiment value for the class'''
#     return Experiment(
#         id=0,
#         priority=0,
#         pin=CURRENT_PIN,
#         target_well="D5",
#         dmf=0,
#         peg=0,
#         acrylate=0,
#         ferrocene=0,
#         custom=0,
#         ocp=1,
#         ca=0,
#         cv=1,
#         baseline = 1,
#         dep_duration=300,
#         dep_pot=-2.7,
#         ca_sample_period=0.01,
#         cv_sample_period=0.01,
#         cv_scan_rate = 0.05,
#         status=ExperimentStatus.QUEUED,
#         status_date=datetime.now(),
#         pumping_rate=0.5,
#         char_sol_name="ferrocene",
#         char_vol=290,
#         flush_sol_name="dmf",
#         flush_vol=120,
#         rinse_count=3,
#         rinse_vol=150,
#         filename= None, #f"test_{datetime.now}.json",
#         results=None)

# def parse_experiment(json_string: str) -> ExperimentBase:
#     '''Parse an experiment from a json string'''
#     return RootModel[ExperimentBase].model_validate_json(json_string).root

# def parse_experimentbase(json_string: str) -> ExperimentBase:
#     '''Parse an experiment from a json string'''
#     return RootModel[ExperimentBase].model_validate_json(json_string).root


def make_test_value() -> ExperimentBase:
    """Create a test experiment value for the class"""
    return ExperimentBase(
        id=0,
        experiment_name="test",
        priority=2,
        well_id="D5",
        pin=CURRENT_PIN,
        project_id=3,
        solutions={"dmf": 0, "peg": 145, "acrylate": 145, "ferrocene": 0, "custom": 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        filename=f"test_{0}.json",
        results=None,
    )


def parse_experiment(json_string: str) -> ExperimentBase:
    """Parse an experiment from a json string"""
    if isinstance(json_string, str):
        parsed_json = json.loads(json_string)
        if "ocp" in parsed_json:
            return RootModel[EchemExperimentBase].model_validate_json(json_string).root
    return RootModel[ExperimentBase].model_validate_json(json_string).root


# def serialize_experiment(experiment: (Experiment,ExperimentBase)) -> str:
#     '''Serialize an experiment to a json string'''
#     if isinstance(experiment, Experiment):
#         return RootModel[Experiment](experiment).model_dump_json(indent=4)


def serialize_experiment(experiment: tuple[ExperimentBase, EchemExperimentBase]) -> str:
    """Given an experiment, determine the type and then pass back the serialized json form"""

    if isinstance(experiment, EchemExperimentBase):
        return RootModel[EchemExperimentBase](experiment).model_dump_json(indent=4)
    if isinstance(experiment, ExperimentBase):
        return RootModel[ExperimentBase](experiment).model_dump_json(indent=4)
    return None


def parse_results(json_string: str) -> ExperimentResult:
    """Parse an experiment result from a json string"""
    return RootModel[ExperimentResult].model_validate_json(json_string).root


def serialize_results(results: ExperimentResult) -> str:
    """Serialize an experiment result to a json string"""
    return RootModel[ExperimentResult](results).model_dump_json(indent=4)


def test_parse():
    """Test that the class can be parsed from json and back"""
    value = make_test_value()
    print(f"Original---> {value}")
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    parsed_value = RootModel[ExperimentBase].model_validate_json(sample_json).root
    print(f"Parsed--->{parsed_value}")
    assert value == parsed_value


def test_serialize_experiment():
    """Test that the class can be serialized to json"""
    value = make_test_value()
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    print(sample_json)
    with open("temp_test_file.json", "w", encoding="UTF-8") as f:
        f.write(sample_json)


def test_serialize_experimentbase():
    """Test that the class can be serialized to json"""
    value = make_test_base_value()
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    print(sample_json)
    with open("temp_test_file.json", "w", encoding="UTF-8") as f:
        f.write(sample_json)


# def test_serialize_layered_experiment():
#     '''Test that the class can be serialized to json'''
#     value = make_test_layered_value()
#     sample_json = RootModel[LayeredExperiments](value).model_dump_json(indent=4)
#     print(sample_json)
#     with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
#         f.write(sample_json)


def test_serialize_results():
    """Test that the class can be serialized to json"""
    value = ExperimentResult(
        id=0,
        well_id="D5",
        ocp_dep_files=["ocp_dep_file"],
        ocp_dep_passes=[True],
        ocp_char_files=["ocp_char_file"],
        ocp_char_passes=[True],
        deposition_data_files=["deposition_data_file"],
        deposition_plot_files=["deposition_plot_file"],
        deposition_max_values=[0.0],
        depsotion_min_values=[0.0],
        characterization_data_files=["characterization_data_file"],
        characterization_plot_files=["characterization_plot_file"],
        characterization_max_values=[0.0],
        characterization_min_values=[0.0],
    )
    sample_json = RootModel[ExperimentResult](value).model_dump_json(indent=4)
    print(sample_json)
    with open("temp_test_file.json", "w", encoding="UTF-8") as f:
        f.write(sample_json)


def test_schema():
    """Test that the class can generate a json schema"""
    # Useful if you have tools that validate your json externally
    print(json.dumps(TypeAdapter(ExperimentBase).json_schema(), indent=4))


if __name__ == "__main__":
    test_serialize_experimentbase()
    test_parse()
    test_schema()
