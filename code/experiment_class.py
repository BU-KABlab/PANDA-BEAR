""" Experiment data class"""
from enum import Enum
from datetime import datetime
from dataclasses import field
from typing import Optional
from pathlib import Path
from pydantic import ConfigDict, FilePath, RootModel, TypeAdapter
from pydantic.dataclasses import dataclass
from config.pin import CURRENT_PIN


class ExperimentStatus(str, Enum):
    '''Define the possible statuses of an experiment'''
    NEW = 'new'
    QUEUED = 'queued'
    RUNNING = 'running'
    OCPCHECK = 'ocpcheck'
    DEPOSITING = 'depositing'
    RINSING = 'rinsing'
    BASELINE = 'baselining'
    CHARACTERIZING = 'characterizing'
    FINAL_RINSE = 'final_rinse'
    COMPLETE = 'complete'
    ERROR = 'error'
    MIXING = 'mixing'

@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentResult:
    '''Define the data that is generated by an experiment'''
    id: int = None
    ocp_dep_file: Path = None
    ocp_dep_pass: bool = None
    ocp_char_file: Path = None
    ocp_char_pass: bool = None
    deposition_data_file: Path = None
    deposition_plot_file: Path = None
    deposition_max_value: float = None
    depsotion_min_value: float = None
    characterization_data_file: Path = None
    characterization_plot_file: Path = None
    characterization_max_value: float = None
    characterization_min_value: float = None


@dataclass(config=ConfigDict(validate_assignment=True))
class Experiment:
    '''Define the data that is used to run an experiment'''
    id: int
    priority: int # 0 is baseline 1 is high priority 2 is normal priority 3 is end baseline
    pin: int
    target_well: str
    dmf: float
    peg: float
    acrylate: float
    ferrocene: float
    custom: float
    ocp: int #Open Circuit Potential
    ca: int #Cyclic Amperometry
    cv: int #Cyclic Voltammetry
    baseline: int #Baseline
    dep_duration: int #Deposition duration
    dep_pot: float #Deposition potential
    char_sol_name: str #Characterization solution name
    char_vol: int   #Characterization solution volume
    flush_sol_name: str #Flush solution name
    flush_vol: int #Flush solution volume
    ca_sample_period: float = 0.01 #Deposition sample period
    cv_sample_period: float = 0.01 #Characterization sample period
    cv_scan_rate: float = 0.05 #Scan rate
    pumping_rate: float = 0.5 #Default pumping rate 0.1 - 0.6 mL/min
    rinse_count: int = 3 #Default rinse count
    rinse_vol: int = 150 #Default rinse volume
    mix: int = 1 #Binary mix or dont mix
    mix_count: int = 3 #Number of times to mix
    mix_vol: int = 200 #Volume to mix
    mix_rate: float = 0.62 #Rate for pump to mix at
    # To restrict this to one of a few values you can use an enum
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: str = None #Optional[FilePath] = None
    # The optional fields seemed to be that way because they were experiment results
    results: Optional[ExperimentResult] = None

    def is_replicate(self, other):
        '''Check if two experiments have the same parameters but different ids'''
        if isinstance(other, Experiment):
            return (self.dmf == other.dmf
                    and self.peg == other.peg
                    and self.acrylate == other.acrylate
                    and self.ferrocene == other.ferrocene
            )
        return False

    def is_same_id(self, other):
        '''Check if two experiments have the same id'''
        if isinstance(other, Experiment):
            return self.id == other.id
        return False


def make_test_value() -> Experiment:
    '''Create a test experiment value for the class'''
    return Experiment(
        id=0,
        priority=2,
        pin=1001001001001001,
        target_well="D5",
        dmf=0,
        peg=145,
        acrylate=145,
        ferrocene=0,
        custom=0,
        ocp=1,
        ca=1,
        cv=1,
        baseline = 0,
        dep_duration=300,
        dep_pot=-2.7,
        ca_sample_period=0.01,
        cv_sample_period=0.01,
        cv_scan_rate = 0.05,
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now(),
        pumping_rate=0.5,
        char_sol_name="ferrocene",
        char_vol=290,
        flush_sol_name="dmf",
        flush_vol=120,
        rinse_count=3,
        rinse_vol=150,
        mix = 1,
        mix_count = 3,
        mix_vol = 200,
        mix_rate = 0.62,
        filename= f"test_{datetime.now}.json",
        results=None)

def make_baseline_value() -> Experiment:
    '''Create a test experiment value for the class'''
    return Experiment(
        id=0,
        priority=0,
        pin=CURRENT_PIN,
        target_well="D5",
        dmf=0,
        peg=0,
        acrylate=0,
        ferrocene=0,
        custom=0,
        ocp=1,
        ca=0,
        cv=1,
        baseline = 1,
        dep_duration=300,
        dep_pot=-2.7,
        ca_sample_period=0.01,
        cv_sample_period=0.01,
        cv_scan_rate = 0.05,
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now(),
        pumping_rate=0.5,
        char_sol_name="ferrocene",
        char_vol=290,
        flush_sol_name="dmf",
        flush_vol=120,
        rinse_count=3,
        rinse_vol=150,
        filename= None, #f"test_{datetime.now}.json",
        results=None)

def parse_experiment(json_string: str) -> Experiment:
    '''Parse an experiment from a json string'''
    return RootModel[Experiment].model_validate_json(json_string).root

def serialize_experiment(experiment: Experiment) -> str:
    '''Serialize an experiment to a json string'''
    return RootModel[Experiment](experiment).model_dump_json(indent=4)

def parse_results(json_string: str) -> ExperimentResult:
    '''Parse an experiment result from a json string'''
    return RootModel[ExperimentResult].model_validate_json(json_string).root

def serialize_results(results: ExperimentResult) -> str:
    '''Serialize an experiment result to a json string'''
    return RootModel[ExperimentResult](results).model_dump_json(indent=4)

def test_parse():
    '''Test that the class can be parsed from json and back'''
    value = make_test_value()
    print(f"Original---> {value}")
    sample_json = RootModel[Experiment](value).model_dump_json(indent=4)
    parsed_value = RootModel[Experiment].model_validate_json(sample_json).root
    print(f"Parsed--->{parsed_value}")
    assert value == parsed_value

def test_serialize():
    '''Test that the class can be serialized to json'''
    value = make_test_value()
    sample_json = RootModel[Experiment](value).model_dump_json(indent=4)
    print(sample_json)
    with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
        f.write(sample_json)

def test_schema():
    '''Test that the class can generate a json schema'''
    # Useful if you have tools that validate your json externally
    import json
    print(json.dumps(TypeAdapter(Experiment).json_schema(), indent=4))

if __name__ == "__main__":
    test_serialize()
    test_parse()
    test_schema()
