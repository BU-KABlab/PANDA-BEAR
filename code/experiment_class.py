""" Experiment data class"""
from enum import Enum
from datetime import datetime
from dataclasses import field
from typing import Optional
from pathlib import Path
from pydantic import ConfigDict, RootModel, TypeAdapter
from pydantic.dataclasses import dataclass
from config.pin import CURRENT_PIN
import json


class ExperimentStatus(str, Enum):
    '''Define the possible statuses of an experiment'''
    NEW = 'new'
    QUEUED = 'queued'
    RUNNING = 'running'
    OCPCHECK = 'ocpcheck'
    DEPOSITING = 'depositing'
    RINSING = 'rinsing'
    BASELINE = 'baselining'
    CHARACTERIZING = 'characterizing'
    FINAL_RINSE = 'final_rinse'
    COMPLETE = 'complete'
    ERROR = 'error'
    MIXING = 'mixing'



@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentResult:
    '''Define the data that is generated by an experiment'''
    id: int = None
    well_id: int = None
    ocp_dep_file: Path = None
    ocp_dep_pass: bool = None
    ocp_char_file: Path = None
    ocp_char_pass: bool = None
    deposition_data_file: Path = None
    deposition_plot_file: Path = None
    deposition_max_value: float = None
    depsotion_min_value: float = None
    characterization_data_file: Path = None
    characterization_plot_file: Path = None
    characterization_max_value: float = None
    characterization_min_value: float = None

@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentBase():
    '''Define the common data used to run and define an experiment'''
    id: int
    experiment_name: str
    priority: int
    target_well: str
    pin: int
    project_id: int
    solutions: dict
    well_type_number = 1
    pumping_rate: float = 0.5 #Default pumping rate 0.1 - 0.6 mL/min
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: str = None #Optional[FilePath] = None
    results: Optional[ExperimentResult] = None
    project_campaign_id: int = None
    protocol_type: int = 1 # 1 is 1 experiment at a time, 2 is layered

    def is_same_id(self, other):
        '''Check if two experiments have the same id'''
        if isinstance(other, PEG_ACR_Instructions):
            return self.id == other.id
        return False

@dataclass(config=ConfigDict(validate_assignment=True))
class EchemExperimentBase(ExperimentBase):
    '''
    Define the data that is used to run an experiment
    
    This is the base class for all echem experiments
    Attributes:
    ------------
    ocp: int
        Open Circuit Potential
    ca: int
        Cyclic Amperometry
    cv: int
        Cyclic Voltammetry
    baseline: int
        Baseline
    flush_sol_name: str
        Flush solution name
    flush_vol: int
        Flush solution volume
    mix = 1
        Binary mix or dont mix
    mix_count: int
        Number of times to mix
    mix_volume: int
        Volume to mix
    rinse_count: int
        Default rinse count
    rinse_vol: int
        Default rinse volume
    ca_sample_period: float
        Deposition sample period
    CAvi: float
        Pre-step voltage (V)
    CAti: float
        Pre-step delay time (s)
    CAv1: float
        Step 1 voltage (V), deposition potential (V)
    CAt1: float
        run time 300 seconds, deposition duration (s)
    CAv2: float
        Step 2 voltage (V)
    CAt2: float
        Step 2 time (s)
    CAsamplerate: float
        sample period (s)
    char_sol_name: str
        Characterization solution name
    char_vol: int
        Characterization solution volume
    cv_sample_period: float
        Characterization sample period
    cv_scan_rate: float
        Scan rate
    CVvi: float
        initial voltage
    CVap1: float
        first anodic peak
    CVap2: float
        second anodic peak
    CVvf: float
        final voltage
    CVstep: float
        step size
    CVsr1: float
        scan rate 1
    CVcycle: int
        number of cycles
    CVsr2: float
        CVsr1
    CVsr3: float
        CVsr1
    CVsamplerate: float
        CVstep / CVsr1

    '''
    ocp: int = 1 #Open Circuit Potential
    ca: int = 1 #Cyclic Amperometry
    cv: int = 1 #Cyclic Voltammetry
    baseline: int = 0 #Baseline

    flush_sol_name: str = 'dmf' #Flush solution name
    flush_vol: int = 100 #Flush solution volume

    mix = 1 #Binary mix or dont mix
    mix_count: int = 3 #Number of times to mix
    mix_volume: int = 130 #Volume to mix
    rinse_count: int = 3 #Default rinse count
    rinse_vol: int = 150 #Default rinse volume

    ca_sample_period: float = 0.1 #Deposition sample period
    CAvi: float = 0.0  # Pre-step voltage (V)
    CAti: float = 0.0  # Pre-step delay time (s)
    CAv1: float = -1.7  # Step 1 voltage (V), deposition potential (V)
    CAt1: float = 300.0  # run time 300 seconds, deposition duration (s)
    CAv2: float = 0.0  # Step 2 voltage (V)
    CAt2: float = 0.0  # Step 2 time (s)
    CAsamplerate: float = 0.5  # sample period (s)


    char_sol_name: str = 'ferrocene' #Characterization solution name
    char_vol: int   = 130 #Characterization solution volume
    cv_sample_period: float = 0.1 #Characterization sample period
    cv_scan_rate: float = 0.05 #Scan rate
    CVvi: float = 0.0  # initial voltage
    CVap1: float = 0.5  # first anodic peak
    CVap2: float = -0.2 # second anodic peak
    CVvf: float = 0.0  # final voltage
    CVstep: float = 0.01 # step size
    CVsr1: float = 0.1 # scan rate 1
    CVcycle: int = 3 # number of cycles
    CVsr2: float = CVsr1
    CVsr3: float = CVsr1
    CVsamplerate: float = CVstep / CVsr1

@dataclass(config=ConfigDict(validate_assignment=True))
class LayeredExperiments(EchemExperimentBase):
    '''Define the data that is used to run an experiment'''
    project_id: int = 4

@dataclass(config=ConfigDict(validate_assignment=True))
class PEG_ACR_Instructions(EchemExperimentBase):
    '''Define the data that is used to run an experiment'''
    project_id: int = 1

@dataclass(config=ConfigDict(validate_assignment=True))
class PEG2P_Test_Instructions(EchemExperimentBase):
    '''Define the data that is used to run an experiment'''
    project_id: int = 2

@dataclass(config=ConfigDict(validate_assignment=True))
class Experiment:
    '''Define the data that is used to run an experiment'''
    id: int
    priority: int # 0 is baseline 1 is high priority 2 is normal priority 3 is end baseline
    pin: int
    target_well: str
    dmf: float
    peg: float
    acrylate: float
    ferrocene: float
    custom: float
    ocp: int #Open Circuit Potential
    ca: int #Cyclic Amperometry
    cv: int #Cyclic Voltammetry
    baseline: int #Baseline
    dep_duration: int #Deposition duration
    dep_pot: float #Deposition potential
    char_sol_name: str #Characterization solution name
    char_vol: int   #Characterization solution volume
    flush_sol_name: str #Flush solution name
    flush_vol: int #Flush solution volume
    ca_sample_period: float = 0.01 #Deposition sample period
    cv_sample_period: float = 0.01 #Characterization sample period
    cv_scan_rate: float = 0.05 #Scan rate
    pumping_rate: float = 0.5 #Default pumping rate 0.1 - 0.6 mL/min
    rinse_count: int = 3 #Default rinse count
    rinse_vol: int = 150 #Default rinse volume
    mix: int = 1 #Binary mix or dont mix
    mix_count: int = 3 #Number of times to mix
    mix_vol: int = 200 #Volume to mix
    mix_rate: float = 0.62 #Rate for pump to mix at
    # To restrict this to one of a few values you can use an enum
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: str = None #Optional[FilePath] = None
    # The optional fields seemed to be that way because they were experiment results
    results: Optional[ExperimentResult] = None
    protocol_type: int = 1 # 1 is 1 experiment at a time, 2 is layered

    def is_replicate(self, other):
        '''Check if two experiments have the same parameters but different ids'''
        if isinstance(other, Experiment):
            return (self.dmf == other.dmf
                    and self.peg == other.peg
                    and self.acrylate == other.acrylate
                    and self.ferrocene == other.ferrocene
            )
        return False

    def is_same_id(self, other):
        '''Check if two experiments have the same id'''
        if isinstance(other, Experiment):
            return self.id == other.id
        return False

def make_test_base_value() -> ExperimentBase:
    '''Create a test experiment value for the class'''
    return ExperimentBase(
        id=0,
        experiment_name= "test",
        priority=2,
        target_well="D5",
        pin=CURRENT_PIN,
        project_id=3,
        solutions={'dmf': 0, 'peg': 145, 'acrylate': 145, 'ferrocene': 0, 'custom': 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        filename= f"test_{0}.json",
        results=None)

def make_test_layered_value(experiment_id: int = 0) -> LayeredExperiments:
    '''Create a test experiment value for the class'''
    return LayeredExperiments(
        id=experiment_id,
        experiment_name= "test",
        priority=2,
        target_well="D5",
        pin=CURRENT_PIN,
        project_id=3,
        solutions={'dmf': 0, 'peg': 145, 'acrylate': 145, 'ferrocene': 0, 'custom': 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        filename= f"test_{id}.json",
        results=None)

def make_test_value() -> Experiment:
    '''Create a test experiment value for the class'''
    return Experiment(
        id=0,
        priority=2,
        pin=1001001001001001,
        target_well="D5",
        dmf=0,
        peg=145,
        acrylate=145,
        ferrocene=0,
        custom=0,
        ocp=1,
        ca=1,
        cv=1,
        baseline = 0,
        dep_duration=300,
        dep_pot=-2.7,
        ca_sample_period=0.01,
        cv_sample_period=0.01,
        cv_scan_rate = 0.05,
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now(),
        pumping_rate=0.5,
        char_sol_name="ferrocene",
        char_vol=290,
        flush_sol_name="dmf",
        flush_vol=120,
        rinse_count=3,
        rinse_vol=150,
        mix = 1,
        mix_count = 3,
        mix_vol = 200,
        mix_rate = 0.62,
        filename= f"test_{datetime.now}.json",
        results=None)

def make_baseline_value() -> Experiment:
    '''Create a test experiment value for the class'''
    return Experiment(
        id=0,
        priority=0,
        pin=CURRENT_PIN,
        target_well="D5",
        dmf=0,
        peg=0,
        acrylate=0,
        ferrocene=0,
        custom=0,
        ocp=1,
        ca=0,
        cv=1,
        baseline = 1,
        dep_duration=300,
        dep_pot=-2.7,
        ca_sample_period=0.01,
        cv_sample_period=0.01,
        cv_scan_rate = 0.05,
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now(),
        pumping_rate=0.5,
        char_sol_name="ferrocene",
        char_vol=290,
        flush_sol_name="dmf",
        flush_vol=120,
        rinse_count=3,
        rinse_vol=150,
        filename= None, #f"test_{datetime.now}.json",
        results=None)

def parse_experiment(json_string: str) -> ExperimentBase:
    '''Parse an experiment from a json string'''
    return RootModel[ExperimentBase].model_validate_json(json_string).root

def parse_experimentbase(json_string: str) -> ExperimentBase:
    '''Parse an experiment from a json string'''
    return RootModel[ExperimentBase].model_validate_json(json_string).root

# def serialize_experiment(experiment: (Experiment,ExperimentBase)) -> str:
#     '''Serialize an experiment to a json string'''
#     if isinstance(experiment, Experiment):
#         return RootModel[Experiment](experiment).model_dump_json(indent=4)

def serialize_experiment(experiment: (ExperimentBase)) -> str:
    """Given an experiment, determine the type and then pass back the serialized json form"""
    if isinstance(experiment, ExperimentBase):
        return RootModel[ExperimentBase](experiment).model_dump_json(indent=4)
    if isinstance(experiment, Experiment):
        return RootModel[Experiment](experiment).model_dump_json(indent=4)
    if isinstance(experiment, PEG2P_Test_Instructions):
        return RootModel[PEG2P_Test_Instructions](experiment).model_dump_json(indent=4)
    if isinstance(experiment, PEG_ACR_Instructions):
        return RootModel[PEG_ACR_Instructions](experiment).model_dump_json(indent=4)
    return None

def parse_results(json_string: str) -> ExperimentResult:
    '''Parse an experiment result from a json string'''
    return RootModel[ExperimentResult].model_validate_json(json_string).root

def serialize_results(results: ExperimentResult) -> str:
    '''Serialize an experiment result to a json string'''
    return RootModel[ExperimentResult](results).model_dump_json(indent=4)

def test_parse():
    '''Test that the class can be parsed from json and back'''
    value = make_test_value()
    print(f"Original---> {value}")
    sample_json = RootModel[Experiment](value).model_dump_json(indent=4)
    parsed_value = RootModel[Experiment].model_validate_json(sample_json).root
    print(f"Parsed--->{parsed_value}")
    assert value == parsed_value

def test_serialize():
    '''Test that the class can be serialized to json'''
    value = make_test_value()
    sample_json = RootModel[Experiment](value).model_dump_json(indent=4)
    print(sample_json)
    with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
        f.write(sample_json)

def test_schema():
    '''Test that the class can generate a json schema'''
    # Useful if you have tools that validate your json externally
    print(json.dumps(TypeAdapter(Experiment).json_schema(), indent=4))

if __name__ == "__main__":
    test_serialize()
    test_parse()
    test_schema()
