""" Experiment data class"""
from enum import Enum
from datetime import datetime
from dataclasses import field
from typing import Optional
from pydantic import ConfigDict, FilePath, RootModel, TypeAdapter
from pydantic.dataclasses import dataclass
from configs.pin import CURRENT_PIN


class ExperimentStatus(str, Enum):
    '''Define the possible statuses of an experiment'''
    NEW = 'new'
    QUEUED = 'queued'
    DEPOSITING = 'depositing'
    RINSING = 'rinsing'
    CHARACTERIZING = 'characterizing'
    FINAL_RINSE = 'final_rinse'
    COMPLETE = 'complete'
    ERROR = 'error'

@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentResult:
    '''Define the data that is generated by an experiment'''
    ocp_dep_file: FilePath = None
    ocp_dep_pass: bool = None
    ocp_char_file: FilePath = None
    ocp_char_pass: bool = None
    deposition_data_file: FilePath = None
    deposition_plot_file: FilePath = None
    deposition_max_value: float = None
    depsotion_min_value: float = None
    characterization_data_file: FilePath = None
    characterization_plot_file: FilePath = None
    characterization_max_value: float = None
    characterization_min_value: float = None


@dataclass(config=ConfigDict(validate_assignment=True))
class Experiment:
    '''Define the data that is used to run an experiment'''
    id: int
    pin: int
    target_well: str
    dmf: float
    peg: float
    acrylate: float
    ferrocene: float
    custom: float
    ocp: int #Open Circuit Potential
    ca: int #Cyclic Amperometry
    cv: int #Cyclic Voltammetry
    baseline: int #Baseline
    dep_duration: int #Deposition duration
    dep_pot: float #Deposition potential
    char_sol_name: str #Characterization solution name
    char_vol: int   #Characterization solution volume
    flush_sol_name: str #Flush solution name
    flush_vol: int #Flush solution volume
    pumping_rate: float = 0.5 #Default pumping rate 0.1 - 0.6 mL/min
    rinse_count: int = 3 #Default rinse count
    rinse_vol: int = 150 #Default rinse volume
    # To restrict this to one of a few values you can use an enum
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: FilePath = None
    # The optional fields seemed to be that way because they were experiment results
    results: Optional[ExperimentResult] = None

    def is_replicate(self, other):
        '''Check if two experiments have the same parameters but different ids'''
        if isinstance(other, Experiment):
            return (self.dmf == other.dmf
                    and self.peg == other.peg
                    and self.acrylate == other.acrylate 
                    and self.ferrocene == other.ferrocene
            )
        return False

    def is_same_id(self, other):
        '''Check if two experiments have the same id'''
        if isinstance(other, Experiment):
            return self.id == other.id
        return False


def make_test_value() -> Experiment:
    '''Create a test experiment value for the class'''
    return Experiment(
        id=1,
        pin=1001001001001001,
        target_well="D5",
        dmf=0,
        peg=145,
        acrylate=145,
        ferrocene=0,
        custom=0,
        ocp=1,
        ca=1,
        cv=1,
        baseline = 0,
        dep_duration=300,
        dep_pot=-2.7,
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now(),
        pumping_rate=0.5,
        char_sol_name="ferrocene",
        char_vol=290,
        flush_sol_name="dmf",
        flush_vol=120,
        rinse_count=3,
        rinse_vol=150,
        filename=None,
        results=None)

def make_baseline_value() -> Experiment:
    '''Create a test experiment value for the class'''
    return Experiment(
        id=1,
        pin=CURRENT_PIN,
        target_well="D5",
        dmf=0,
        peg=0,
        acrylate=0,
        ferrocene=0,
        custom=0,
        ocp=1,
        ca=0,
        cv=1,
        baseline = 1,
        dep_duration=300,
        dep_pot=-2.7,
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now(),
        pumping_rate=0.5,
        char_sol_name="ferrocene",
        char_vol=290,
        flush_sol_name="dmf",
        flush_vol=120,
        rinse_count=3,
        rinse_vol=150,
        filename=None,
        results=None)

def test_parse():
    '''Test that the class can be parsed from json and back'''
    value = make_test_value()
    print(f"Original---> {value}")
    sample_json = RootModel[Experiment](value).model_dump_json(indent=4)
    parsed_value = RootModel[Experiment].model_validate_json(sample_json).root
    print(f"Parsed--->{parsed_value}")
    assert(value == parsed_value)

def test_serialize():
    '''Test that the class can be serialized to json'''
    value = make_test_value()
    sample_json = RootModel[Experiment](value).model_dump_json(indent=4)
    print(sample_json)
    with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
        f.write(sample_json)

def test_schema():
    '''Test that the class can generate a json schema'''
    # Useful if you have tools that validate your json externally
    import json
    print(json.dumps(TypeAdapter(Experiment).json_schema(), indent=4))

if __name__ == "__main__":
    test_serialize()
    test_parse()
    test_schema()
