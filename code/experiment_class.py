""" Experiment data class"""
import json
from dataclasses import field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Optional

from config.pin import CURRENT_PIN
from pydantic import ConfigDict, RootModel, TypeAdapter
from pydantic.dataclasses import dataclass


class ExperimentStatus(str, Enum):
    '''Define the possible statuses of an experiment'''
    NEW = 'new'
    QUEUED = 'queued'
    RUNNING = 'running'
    OCPCHECK = 'ocpcheck'
    DEPOSITING = 'depositing'
    EDEPOSITING = 'e_depositing'
    RINSING = 'rinsing'
    ERINSING = 'rinsing electrode'
    BASELINE = 'baselining'
    CHARACTERIZING = 'characterizing'
    CA = 'cyclic-amperometry'
    CV = 'cyclic-voltametry'
    FINAL_RINSE = 'final_rinse'
    COMPLETE = 'complete'
    ERROR = 'error'
    MIXING = 'mixing'
    IMAGING = 'imaging'
    CLEARING = 'clearing'
    FLUSHING = 'flushing'



@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentResult:
    '''Define the data that is generated by an experiment'''
    id: int = None
    well_id: str = None
    ocp_dep_file: Path = None
    ocp_dep_pass: bool = None
    ocp_char_file: Path = None
    ocp_char_pass: bool = None
    deposition_data_file: Path = None
    deposition_plot_file: Path = None
    deposition_max_value: float = None
    depsotion_min_value: float = None
    characterization_data_file: Path = None
    characterization_plot_file: Path = None
    characterization_max_value: float = None
    characterization_min_value: float = None
    pumping_record: list = None
    image_file: Path = None

@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentBase():
    '''Define the common data used to run and define an experiment'''
    id: int = None
    experiment_name: str = None
    priority: int = None
    well_id: Optional[str] = None
    pin: int = None
    project_id: int = None
    solutions: dict = None
    solutions_corrected: dict = None
    well_type_number:int = 1
    pumping_rate: float = 0.3
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: str = None #Optional[FilePath] = None
    results: Optional[ExperimentResult] = None
    project_campaign_id: int = None
    protocol_type: int = 1 # 1 is 1 experiment at a time, 2 is layered
    plate_id: Optional[int] = None
    override_well_selection: int = 0 # 0 is normal, 1 is override
    process_type: int = 1 # 1 is 5mm_FeCN, 2 is 10mm_FeCN first, 3 is 10mm_FeCN second


    def set_status(self, new_status: ExperimentStatus):
        '''Set the status and status date of the experiment'''
        self.status = new_status
        self.status_date = datetime.now()
        try:
            from obs_controls import OBSController
            OBSController().place_experiment_on_screen(self)
        except Exception as e:
            print(f"Error setting status: {e}")
    # @property
    # def solutions_corrected(self):
    #     '''Calculate the corrected volume for each solution'''
    #     if self.solutions is not None:
    #         return {
    #             key: correction_factor(value, viscosity=None)
    #             for key, value in self.solutions.items()
    #         }
    #     return None

    def is_same_id(self, other):
        '''Check if two experiments have the same id'''
        pass

@dataclass(config=ConfigDict(validate_assignment=True))
class CorrectionFactorExperiment(ExperimentBase):
    '''Define the data that is used to run an experiment'''
    project_id: int = 11
    correction_factor: float = 1.0

@dataclass(config=ConfigDict(validate_assignment=True))
class EchemExperimentBase(ExperimentBase):
    '''
    Define the data that is used to run an experiment
    
    This is the base class for all echem experiments
    Attributes:
    ------------
    ocp: int
        Open Circuit Potential
    ca: int
        Cyclic Amperometry
    cv: int
        Cyclic Voltammetry
    baseline: int
        Baseline
    flush_sol_name: str
        Flush solution name
    flush_vol: int
        Flush solution volume
    mix = 1
        Binary mix or dont mix
    mix_count: int
        Number of times to mix
    mix_volume: int
        Volume to mix
    rinse_count: int
        Default rinse count
    rinse_vol: int
        Default rinse volume
    ca_sample_period: float
        Deposition sample period
    CAvi: float
        Pre-step voltage (V)
    CAti: float
        Pre-step delay time (s)
    CAv1: float
        Step 1 voltage (V), deposition potential (V)
    CAt1: float
        run time 300 seconds, deposition duration (s)
    CAv2: float
        Step 2 voltage (V)
    CAt2: float
        Step 2 time (s)
    CAsamplerate: float
        sample period (s)
    char_sol_name: str
        Characterization solution name
    char_vol: int
        Characterization solution volume
    cv_sample_period: float
        Characterization sample period
    cv_scan_rate: float
        Scan rate
    CVvi: float
        initial voltage
    CVap1: float
        first anodic peak
    CVap2: float
        second anodic peak
    CVvf: float
        final voltage
    CVstep: float
        step size
    CVsr1: float
        scan rate 1
    CVcycle: int
        number of cycles
    CVsr2: float
        CVsr1
    CVsr3: float
        CVsr1
    CVsamplerate: float
        CVstep / CVsr1

    '''
    ocp: int = 1 #Open Circuit Potential
    ca: int = 1 #Cyclic Amperometry
    cv: int = 1 #Cyclic Voltammetry
    baseline: int = 0 #Baseline

    flush_sol_name: str = '' #Flush solution name
    flush_vol: int = 0 #Flush solution volume

    mix = 0 #Binary mix or dont mix
    mix_count: int = 0 #Number of times to mix
    mix_volume: int = 0 #Volume to mix
    rinse_count: int = 4 #Default rinse count
    rinse_vol: int = 0 #Default rinse volume

    ca_sample_period: float = 0.1 #Deposition sample period
    ca_prestep_voltage: float = 0.0  # Pre-step voltage (V)
    # CAvi = ca_prestep_voltage
    ca_prestep_time_delay: float = 0.0  # Pre-step delay time (s)
    # CAti = ca_prestep_time_delay
    ca_step_1_voltage: float = -1.7  # Step 1 voltage (V), deposition potential (V)
    # CAv1 = ca_step_1_voltage
    ca_step_1_time: float = 300.0  # run time 300 seconds, deposition duration (s)
    # CAt1 = ca_step_1_time
    ca_step_2_voltage: float = 0.0  # Step 2 voltage (V)
    # CAv2 = ca_step_2_voltage
    ca_step_2_time: float = 0.0  # Step 2 time (s)
    # CAt2 = ca_step_2_time
    ca_sample_rate: float = 0.5  # sample period (s)
    # CAsamplerate = ca_sample_rate


    char_sol_name: str = '' #Characterization solution name
    char_vol: int   = 0 #Characterization solution volume
    cv_sample_period: float = 0.1 #Characterization sample period
    cv_initial_voltage: float = 0.0  # initial voltage
    cv_first_anodic_peak: float = 0.5  # first anodic peak
    cv_second_anodic_peak: float = -0.2 # second anodic peak
    cv_final_voltage: float = 0.0  # final voltage
    cv_step_size: float = 0.01 # step size
    cv_cycle_count: int = 3 # number of cycles
    cv_scan_rate_cycle_1: float = 0.1
    cv_scan_rate_cycle_2: float = 0.1
    cv_scan_rate_cycle_3: float = 0.1

    # CVvi: float = 0.0  # initial voltage
    # CVap1: float = 0.5  # first anodic peak
    # CVap2: float = -0.2 # second anodic peak
    # CVvf: float = 0.0  # final voltage
    # CVstep: float = 0.01 # step size
    # CVsr1: float = 0.1 # scan rate 1
    # CVcycle: int = 3 # number of cycles
    # CVsr2: float = CVsr1
    # CVsr3: float = CVsr1

    @property
    def cv_sample_rate(self):
        '''CVstep / CVsr1'''
        return round(self.cv_step_size / self.cv_scan_rate_cycle_1,4)

    def print_ca_parameters(self):
        '''Print the CA parameters'''
        if self.ca:
            return f"""
        CA Parameters
            Pre-step Voltage: {self.ca_prestep_voltage}
            Pre-step Time Delay: {self.ca_prestep_time_delay}
            Step 1 Voltage: {self.ca_step_1_voltage}
            Step 1 Time: {self.ca_step_1_time}
            Step 2 Voltage: {self.ca_step_2_voltage}
            Step 2 Time: {self.ca_step_2_time}
            CA Sample Rate: {self.ca_sample_rate}
    """
        else:
            return f"""
        CA Parameters
            Pre-step Voltage: N/A
            Pre-step Time Delay: N/A
            Step 1 Voltage: N/A
            Step 1 Time: N/A
            Step 2 Voltage: N/A
            Step 2 Time: N/A
            CA Sample Rate: N/A
    """


    def print_cv_parameters(self):
        '''Print the CV parameters'''
        if self.cv:
            return f"""
        CV Parameters
            CV: {bool(self.cv)}
            CV Baseline: {bool(self.baseline)}
            Sample Period: {self.cv_sample_period}
            Initial Voltage (CVvi): {self.cv_initial_voltage}
            First Anodic Peak (CVap1): {self.cv_first_anodic_peak}
            Second Anodic Peak (CVap2): {self.cv_second_anodic_peak}
            Final Voltage (CVvf): {self.cv_final_voltage}
            Step Size (CVstep): {self.cv_step_size}
            Cycle Count: {self.cv_cycle_count}
            Scan Rate Cycle 1 (CVsr1): {self.cv_scan_rate_cycle_1}
            Scan Rate Cycle 2 (CVsr2): {self.cv_scan_rate_cycle_2}
            Scan Rate Cycle 3 (CVsr3): {self.cv_scan_rate_cycle_3}
            CV Sample Rate: {self.cv_sample_rate}
    """
        else:
            return f"""
        CV Parameters
            CV: {bool(self.cv)}
            CV Baseline: {bool(self.baseline)}
            Sample Period: N/A
            Initial Voltage (CVvi): N/A
            First Anodic Peak (CVap1): N/A
            Second Anodic Peak (CVap2): N/A
            Final Voltage (CVvf): N/A
            Step Size (CVstep): N/A
            Cycle Count: N/A
            Scan Rate Cycle 1 (CVsr1): N/A
            Scan Rate Cycle 2 (CVsr2): N/A
            Scan Rate Cycle 3 (CVsr3): N/A
            CV Sample Rate: N/A
"""
    def print_all_experiment_parameters(self):
        '''Print the experiment parameters'''
        return f"""
{self.experiment_name} 
        Plate #: {self.plate_id}
        Experiment ID: {self.id}
        Well ID: {self.well_id}
        Status: {self.status.value}
        Priority: {self.priority}
        Solutions: {self.solutions}
        Corrected Solutions: {self.solutions_corrected}
        Filename: {self.filename}

        Echem Parameters
            Run Open Circuit Potential: {bool(self.ocp)}
            Run Cyclic Amperometry: {bool(self.ca)}
            Run Cyclic Voltammetry: {bool(self.cv)}
            Run CV Baseline: {bool(self.baseline)}
            Flush Solution Name: {self.flush_sol_name}
            Flush Solution Volume: {self.flush_vol}
            Mix: {bool(self.mix)}
            Mix Count: {self.mix_count}
            Mix Volume: {self.mix_volume}
            Rinse Count: {self.rinse_count}
            Rinse Volume: {self.rinse_vol}

        {self.print_ca_parameters()}

        {self.print_cv_parameters()}
    """

# @dataclass(config=ConfigDict(validate_assignment=True))
# class Experiment:
#     '''Define the data that is used to run an experiment'''
#     id: int
#     priority: int # 0 is baseline 1 is high priority 2 is normal priority 3 is end baseline
#     pin: int
#     target_well: str
#     dmf: float
#     peg: float
#     acrylate: float
#     ferrocene: float
#     custom: float
#     ocp: int #Open Circuit Potential
#     ca: int #Cyclic Amperometry
#     cv: int #Cyclic Voltammetry
#     baseline: int #Baseline
#     dep_duration: int #Deposition duration
#     dep_pot: float #Deposition potential
#     char_sol_name: str #Characterization solution name
#     char_vol: int   #Characterization solution volume
#     flush_sol_name: str #Flush solution name
#     flush_vol: int #Flush solution volume
#     ca_sample_period: float = 0.01 #Deposition sample period
#     cv_sample_period: float = 0.01 #Characterization sample period
#     cv_scan_rate: float = 0.05 #Scan rate
#     pumping_rate: float = 0.5 #Default pumping rate 0.1 - 0.6 mL/min
#     rinse_count: int = 3 #Default rinse count
#     rinse_vol: int = 150 #Default rinse volume
#     mix: int = 1 #Binary mix or dont mix
#     mix_count: int = 3 #Number of times to mix
#     mix_vol: int = 200 #Volume to mix
#     mix_rate: float = 0.62 #Rate for pump to mix at
#     # To restrict this to one of a few values you can use an enum
#     status: ExperimentStatus = ExperimentStatus.NEW
#     status_date: datetime = field(default_factory=datetime.now)
#     filename: str = None #Optional[FilePath] = None
#     # The optional fields seemed to be that way because they were experiment results
#     results: Optional[ExperimentResult] = None
#     protocol_type: int = 1 # 1 is 1 experiment at a time, 2 is layered

#     def is_replicate(self, other):
#         '''Check if two experiments have the same parameters but different ids'''
#         if isinstance(other, Experiment):
#             return (self.dmf == other.dmf
#                     and self.peg == other.peg
#                     and self.acrylate == other.acrylate
#                     and self.ferrocene == other.ferrocene
#             )
#         return False

#     def is_same_id(self, other):
#         '''Check if two experiments have the same id'''
#         if isinstance(other, Experiment):
#             return self.id == other.id
#         return False

def make_test_base_value() -> ExperimentBase:
    '''Create a test experiment value for the class'''
    return ExperimentBase(
        id=0,
        experiment_name= "test",
        priority=2,
        well_id="D5",
        pin=CURRENT_PIN,
        project_id=3,
        solutions={'dmf': 0, 'peg': 145, 'acrylate': 145, 'ferrocene': 0, 'custom': 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        filename= f"test_{0}.json",
        results=None)

# def make_test_value() -> Experiment:
#     '''Create a test experiment value for the class'''
#     return Experiment(
#         id=0,
#         priority=2,
#         pin=1001001001001001,
#         target_well="D5",
#         dmf=0,
#         peg=145,
#         acrylate=145,
#         ferrocene=0,
#         custom=0,
#         ocp=1,
#         ca=1,
#         cv=1,
#         baseline = 0,
#         dep_duration=300,
#         dep_pot=-2.7,
#         ca_sample_period=0.01,
#         cv_sample_period=0.01,
#         cv_scan_rate = 0.05,
#         status=ExperimentStatus.QUEUED,
#         status_date=datetime.now(),
#         pumping_rate=0.5,
#         char_sol_name="ferrocene",
#         char_vol=290,
#         flush_sol_name="dmf",
#         flush_vol=120,
#         rinse_count=3,
#         rinse_vol=150,
#         mix = 1,
#         mix_count = 3,
#         mix_vol = 200,
#         mix_rate = 0.62,
#         filename= f"test_{datetime.now}.json",
#         results=None)

# def make_baseline_value() -> Experiment:
#     '''Create a test experiment value for the class'''
#     return Experiment(
#         id=0,
#         priority=0,
#         pin=CURRENT_PIN,
#         target_well="D5",
#         dmf=0,
#         peg=0,
#         acrylate=0,
#         ferrocene=0,
#         custom=0,
#         ocp=1,
#         ca=0,
#         cv=1,
#         baseline = 1,
#         dep_duration=300,
#         dep_pot=-2.7,
#         ca_sample_period=0.01,
#         cv_sample_period=0.01,
#         cv_scan_rate = 0.05,
#         status=ExperimentStatus.QUEUED,
#         status_date=datetime.now(),
#         pumping_rate=0.5,
#         char_sol_name="ferrocene",
#         char_vol=290,
#         flush_sol_name="dmf",
#         flush_vol=120,
#         rinse_count=3,
#         rinse_vol=150,
#         filename= None, #f"test_{datetime.now}.json",
#         results=None)

# def parse_experiment(json_string: str) -> ExperimentBase:
#     '''Parse an experiment from a json string'''
#     return RootModel[ExperimentBase].model_validate_json(json_string).root

# def parse_experimentbase(json_string: str) -> ExperimentBase:
#     '''Parse an experiment from a json string'''
#     return RootModel[ExperimentBase].model_validate_json(json_string).root

def make_test_value() -> ExperimentBase:
    '''Create a test experiment value for the class'''
    return ExperimentBase(
        id=0,
        experiment_name= "test",
        priority=2,
        well_id="D5",
        pin=CURRENT_PIN,
        project_id=3,
        solutions={'dmf': 0, 'peg': 145, 'acrylate': 145, 'ferrocene': 0, 'custom': 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        filename= f"test_{0}.json",
        results=None)

def parse_experiment(json_string: str) -> (ExperimentBase, EchemExperimentBase):
    '''Parse an experiment from a json string'''
    if isinstance(json_string, str):
        parsed_json = json.loads(json_string)
        if "ocp" in parsed_json:
            return RootModel[EchemExperimentBase].model_validate_json(json_string).root
    return RootModel[ExperimentBase].model_validate_json(json_string).root

# def serialize_experiment(experiment: (Experiment,ExperimentBase)) -> str:
#     '''Serialize an experiment to a json string'''
#     if isinstance(experiment, Experiment):
#         return RootModel[Experiment](experiment).model_dump_json(indent=4)

def serialize_experiment(experiment: (ExperimentBase, EchemExperimentBase)) -> str:
    """Given an experiment, determine the type and then pass back the serialized json form"""
    
    if isinstance(experiment, EchemExperimentBase):
        return RootModel[EchemExperimentBase](experiment).model_dump_json(indent=4)
    if isinstance(experiment, ExperimentBase):
        return RootModel[ExperimentBase](experiment).model_dump_json(indent=4)
    return None

def parse_results(json_string: str) -> ExperimentResult:
    '''Parse an experiment result from a json string'''
    return RootModel[ExperimentResult].model_validate_json(json_string).root

def serialize_results(results: ExperimentResult) -> str:
    '''Serialize an experiment result to a json string'''
    return RootModel[ExperimentResult](results).model_dump_json(indent=4)

def test_parse():
    '''Test that the class can be parsed from json and back'''
    value = make_test_value()
    print(f"Original---> {value}")
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    parsed_value = RootModel[ExperimentBase].model_validate_json(sample_json).root
    print(f"Parsed--->{parsed_value}")
    assert value == parsed_value

def test_serialize_experiment():
    '''Test that the class can be serialized to json'''
    value = make_test_value()
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    print(sample_json)
    with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
        f.write(sample_json)

def test_serialize_experimentbase():
    '''Test that the class can be serialized to json'''
    value = make_test_base_value()
    sample_json = RootModel[ExperimentBase](value).model_dump_json(indent=4)
    print(sample_json)
    with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
        f.write(sample_json)

# def test_serialize_layered_experiment():
#     '''Test that the class can be serialized to json'''
#     value = make_test_layered_value()
#     sample_json = RootModel[LayeredExperiments](value).model_dump_json(indent=4)
#     print(sample_json)
#     with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
#         f.write(sample_json)

def test_serialize_results():
    '''Test that the class can be serialized to json'''
    value = ExperimentResult(
        id=0,
        well_id="D5",
        ocp_dep_file="ocp_dep_file",
        ocp_dep_pass=True,
        ocp_char_file="ocp_char_file",
        ocp_char_pass=True,
        deposition_data_file="deposition_data_file",
        deposition_plot_file="deposition_plot_file",
        deposition_max_value=0.0,
        depsotion_min_value=0.0,
        characterization_data_file="characterization_data_file",
        characterization_plot_file="characterization_plot_file",
        characterization_max_value=0.0,
        characterization_min_value=0.0)
    sample_json = RootModel[ExperimentResult](value).model_dump_json(indent=4)
    print(sample_json)
    with open('temp_test_file.json', 'w', encoding='UTF-8') as f:
        f.write(sample_json)

def test_schema():
    '''Test that the class can generate a json schema'''
    # Useful if you have tools that validate your json externally
    print(json.dumps(TypeAdapter(ExperimentBase).json_schema(), indent=4))

if __name__ == "__main__":
    test_serialize_experimentbase()
    test_parse()
    test_schema()
