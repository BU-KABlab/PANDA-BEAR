"""
Solid Handling Demonstration Protocol

This script demonstrates solid handling capabilities including:
- Multiple Arduino connections (light ring, electromagnet, linebreak sensor)
- Decapping and capping operations
- Precise mill movement (rectangular pattern)
- Imaging with light control
- Interaction with gel surfaces
"""

import time
import logging
import asyncio
from pathlib import Path
from datetime import datetime

# PANDA system imports
from panda_lib.hardware import ArduinoLink, PandaMill 
#from panda_lib.hardware.panda_pipettes import Pipette, insert_new_pipette
from panda_lib.hardware.arduino_interface import PawduinoFunctions
from panda_lib.toolkit import Toolkit
from panda_lib.types import VialKwargs
from panda_lib.labware.vials import StockVial
from panda_lib.actions.movement import decapping_sequence, capping_sequence

# Set up logging
logger = logging.getLogger("solid_handling_demo")
logger.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Create output directory
timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
output_dir = Path(f"solid_handling_demo_{timestamp}")
output_dir.mkdir(exist_ok=True)

# Create file handler
file_handler = logging.FileHandler(output_dir / "solid_handling_demo.log")
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

# Create console handler
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(formatter)
logger.addHandler(console_handler)

# Constants
vial_x = -16.5  # X coordinate for stock vial
vial_y = -40  # Y coordinate for stock vial
vial_z_touch = -80  # Z coordinate for stock vial right above powder
well_a1_x = -167  # X coordinate for wellplate A1
well_a1_y = -50  # Y coordinate for wellplate A1
well_a1_z_touch = -91  # Z coordinate for wellplate A1 (base level)
safe_z = 0


# Add this near the top of your script, after imports
DRY_RUN = False  # Set to False when you want to actually run the movements

# Create a class to replace the PandaMill for dry runs
class DryRunMill:
    """A mock mill that logs commands but doesn't move."""
    
    def __init__(self):
        self.current_position = {"x": 0, "y": 0, "z": 0}
        self.current_tool = None
        self.log_file = Path("dry_run_movements.csv")
        
        # Create log file with headers
        with open(self.log_file, 'w') as f:
            f.write("command,x,y,z,tool,feed_rate,notes\n")
        
        print(f"üîç DRY RUN MODE ACTIVE - No actual movements will occur")
        print(f"üìù Movement commands will be logged to: {self.log_file}")
    
    def log_movement(self, command, x=None, y=None, z=None, tool=None, feed_rate=None, notes=None):
        """Log a movement command to CSV file."""
        with open(self.log_file, 'a') as f:
            f.write(f"{command},{x},{y},{z},{tool},{feed_rate},{notes}\n")
        
        # Also print to console
        tool_str = f", tool: {tool}" if tool else ""
        position_str = ", ".join([f"{axis}: {val}" for axis, val in 
                                 [("x", x), ("y", y), ("z", z)] if val is not None])
        print(f"üîç {command}: {position_str}{tool_str}")
        
        # Update current position
        if x is not None: self.current_position["x"] = x
        if y is not None: self.current_position["y"] = y
        if z is not None: self.current_position["z"] = z
        if tool is not None: self.current_tool = tool
    
    # Implement all the methods from PandaMill that your script uses
    def connect_to_mill(self):
        print("üîç Would connect to mill")
        return True
    
    def homing_sequence(self):
        self.log_movement("homing", 0, 0, 0, notes="Homing sequence")
        return True
    
    def set_feed_rate(self, rate):
        self.log_movement("set_feed_rate", feed_rate=rate, notes="Set feed rate")
        return True
    
    def move_to_position(self, x=None, y=None, z=None, tool=None, **kwargs):
        self.log_movement("move_to_position", x, y, z, tool, notes=str(kwargs) if kwargs else None)
        return True
    
    def safe_move(self, x=None, y=None, z=None, tool=None, **kwargs):
        # Check if x is actually a dictionary of coordinates
        if isinstance(x, dict) and 'x' in x and 'y' in x:
            coords = x
            x = coords.get('x')
            y = coords.get('y')
            z = coords.get('z')
        
        self.log_movement("safe_move", x, y, z, tool, notes=str(kwargs) if kwargs else None)
        return True
    
    def move_to_safe_position(self):
        self.log_movement("move_to_safe_position", 0, 0, 0, notes="Moving to safe position")
        return True
    
    def disconnect(self):
        print("üîç Would disconnect from mill")
        return True
    
    def send_command(self, command):
        self.log_movement("send_command", notes=command)
        return "OK"

# Create a mock ArduinoLink class for dry run
class DryRunArduino:
    """A mock Arduino that logs commands but doesn't communicate."""
    
    def __init__(self, port=None, **kwargs):
        self.port = port
        self._cap_present = False  # Initialize with no cap present
        print(f"üîç DRY RUN MODE: Would connect to Arduino on {port}")
    
    def send(self, command, *args):
        arg_str = ", ".join([str(arg) for arg in args]) if args else ""
        print(f"üîç Arduino command: {command} {arg_str}")
        return {"msg": "DRY RUN OK"}
    
    def send_command(self, command, *args):
        return self.send(command, *args)

    def get_status(self):
        print("üîç Arduino get_status called")
        return {
            "plunger_position": 36.0,
            "status": "idle",
            "error": None
        }
    
    def no_cap(self):
        """Check if no cap is present."""
        print(f"üîç Arduino no_cap: Cap present = {self._cap_present}")
        # For decapping, we want this to return True (no cap) after decapping
        # In dry run mode, we'll simulate that the cap is removed after decapping
        self._cap_present = False  # Simulate successful decapping
        return {"msg": "DRY RUN OK", "result": not self._cap_present}
    
    def has_cap(self):
        """Check if a cap is present."""
        print(f"üîç Arduino has_cap: Cap present = {self._cap_present}")
        # For capping, we want this to return True (has cap) after capping
        # In dry run mode, we'll simulate that the cap is placed after capping
        self._cap_present = True  # Simulate successful capping
        return {"msg": "DRY RUN OK", "result": self._cap_present}
    
    async def async_line_break(self):
        """Mock method for asynchronous line break detection."""
        print("üîç Arduino async_line_break: Would detect line break")
        # After decapping, line break should detect no cap (true)
        # After capping, line break should detect a cap (false)
        detected = not self._cap_present  # If cap is NOT present, line break IS detected
        print(f"üîç Line break detected: {detected} (cap present: {self._cap_present})")
        # Simulate a short delay to mimic real behavior
        await asyncio.sleep(0.5)
        return {"detected": detected, "msg": "DRY RUN OK"}
    
    def ALL_CAP(self):
        """Mock method to indicate all caps are detected/engaged."""
        print("üîç Arduino ALL_CAP: Would indicate all caps are detected")
        # Simulate that the caps are detected
        self._cap_present = True
        return {"msg": "DRY RUN OK", "result": True}

# Add this class after your DryRunArduino class definition
class CoordinateObject:
    """Simple class to hold x, y, z coordinates with attribute access."""
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

# Add this code before your "try" block
if DRY_RUN:
    # Replace actual hardware classes with dry run versions
    PandaMill = DryRunMill
    ArduinoLink = DryRunArduino
    
# Should return a valid dummy image instead of None
    def mock_camera_init(*args, **kwargs):
        class MockCamera:
            def isOpened(self): 
                return True
                
            def read(self): 
                # Create a small black dummy image instead of None
                import numpy as np
                dummy_image = np.zeros((480, 640, 3), dtype=np.uint8)
                # Add some text to indicate it's a mock image
                if cv2.__version__ >= '4':
                    cv2.putText(dummy_image, "MOCK CAMERA IMAGE", (50, 240), 
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
                return (True, dummy_image)
                
            def release(self): 
                pass
        return MockCamera()
    
    # Patch cv2.VideoCapture
    import cv2
    cv2.VideoCapture = mock_camera_init

        # Store original functions
    original_decapping = decapping_sequence
    original_capping = capping_sequence
    
    # Create a mock capping sequence that works around the bug
    def mock_capping_sequence(mill, coords, arduino, **kwargs):
        """Mock implementation of capping that works in dry run mode."""
        print("üîç MOCK CAPPING: Would cap vial")
        
        # Log the movements
        mill.log_movement("capping", coords.x, coords.y, coords.z, 
                          tool="decapper", notes="Start capping sequence")
        mill.safe_move(coords.x, coords.y, coords.z, tool="decapper")
        
        # Simulate the ALL_CAP call
        arduino.ALL_CAP()
        
        # Move to safe position
        mill.move_to_position(coords.x, coords.y, 0, tool="decapper")
        
        # This is the part that's broken in the real function - we'll skip it
        print("üîç SKIPPING problematic line break check in capping sequence")
        
        # Indicate success
        return True
    
    capping_sequence = mock_capping_sequence


try:
    # ===== HARDWARE SETUP =====
    logger.info("Initializing hardware components...")
    
    # Initialize the mill
    mill = PandaMill()
    
    
    # Main Arduino 
    arduino = ArduinoLink("/dev/ttyACM1")
    
    # Create toolkit
    tools = Toolkit(
        mill=PandaMill(),
        arduino=arduino,
        global_logger=logger,
        use_mock_instruments=DRY_RUN,
    )
    
    logger.info("Successfully initialized hardware")
    # Verify camera type
    logger.info(f"Using camera: {tools.camera.__class__.__name__}")
    # ===== LABWARE SETUP =====
    
    # Set up stock vial 1
    vkwargs_stock = VialKwargs(
        category=0,
        name="Solid_Sample",
        contents={"solid_particles": 10000},
        viscosity_cp=1,  # Not applicable for solids
        concentration=0.01,
        density=1,
        height=66,
        radius=14,
        volume=10000,
        capacity=20000,
        contamination=0,
        coordinates={
            "x": vial_x,
            "y": vial_y,
            "z": -197.0,
        },
        base_thickness=1,
        dead_volume=0,
    )
    
    stock_vial = StockVial(
        position="s1", create_new=True, **vkwargs_stock
    )
    stock_vial.save()
    
      
    # ===== RECTANGULAR MOVEMENT PATTERN =====
    # Define rectangular movement pattern (adjust as needed)
    rect_pattern = [
        {"x": 0, "y": 0},      # Starting point (relative to vial center)
        {"x": 2, "y": 0},      # Right
        {"x": 2, "y": 2},      # Up
        {"x": 0, "y": 2},      # Left
        {"x": 0, "y": 0}       # Back to start
    ]
    
    # ===== EXECUTE PROTOCOL =====
    logger.info("Beginning solid handling protocol")
    
    # Home the mill
    logger.info("Homing mill...")
    mill.connect_to_mill()
    mill.homing_sequence()
    mill.set_feed_rate(3000)  # Slower for solid handling
    
    # 1. Decap stock vial 1
    logger.info("Decapping stock vial 1...")
    decapping_sequence(
        mill, 
        CoordinateObject(stock_vial.coordinates.x, stock_vial.coordinates.y, stock_vial.top), 
        arduino
    )
    
    # 2. Move pipette to stock vial 1
    logger.info("Moving pipette to stock vial 1...")
    mill.safe_move(
        stock_vial.coordinates.x,
        stock_vial.coordinates.y,
        stock_vial.bottom + 80,  # Position above vial 
        tool="pipette"
    )
    
    # 3. Lower pipette into stock vial
    logger.info("Lowering pipette into stock vial...")
    mill.safe_move(
        stock_vial.coordinates.x,
        stock_vial.coordinates.y,
        stock_vial.bottom + 30,  #TODO upddate this before running
        tool="pipette"
    )
    
   

    # 4. Move in rectangular pattern
    logger.info("Executing rectangular movement pattern...")
    base_x = stock_vial.coordinates.x
    base_y = stock_vial.coordinates.y
    base_z = stock_vial.bottom + 30 #TODO update this before running
    
    for point in rect_pattern:
        target_x = base_x + point["x"]
        target_y = base_y + point["y"]
        logger.info(f"Moving to relative position: ({point['x']}, {point['y']})")
        mill.move_to_position(target_x, target_y, base_z, tool="pipette")
    
    # 5. Raise pipette up
    logger.info("Raising pipette...")
    mill.safe_move(
        stock_vial.coordinates.x,
        stock_vial.coordinates.y,
        stock_vial.bottom + 80,
        tool="pipette"
    )
    
    # 6. Cap the stock vial
    logger.info("Capping stock vial 1...")
    capping_sequence(
        mill, 
        CoordinateObject(stock_vial.coordinates.x, stock_vial.coordinates.y, stock_vial.top), 
        arduino
    )
    
    # 7. Move pipette to wellplate 
    logger.info("Moving to wellplate position...")
    mill.safe_move(
        well_a1_x,
        well_a1_y,
        stock_vial.bottom + 80,  # Position above well
        tool="pipette"
    )
    
    # 8. Lower pipette to touch gel surface
    logger.info("Lowering pipette to gel surface...")
    mill.move_to_position(
        well_a1_x,
        well_a1_y,
        well_a1_z_touch,  # Gel surface level
        tool="pipette",
    )
    
    # Move pipette to safe position above gel
    mill.move_to_safe_position()

    # Move camera into position to take picture
    mill.safe_move(
        well_a1_x,
        well_a1_y,
        safe_z,
        tool="lens"
    )
        
    # 9. Turn on light ring
    logger.info("Turning on light ring...")
    try:
        arduino.send(PawduinoFunctions.CMD_WHITE_ON)
    except Exception as e:
        logger.warning(f"Could not control light ring: {e}")
        
    # 10. Take picture
    logger.info("Capturing image...")
    image_path = output_dir / f"gel_well_image_{timestamp}.jpg"
    
    # Alternative: Capture sequence of images
    fps = 1  # Frames per second
    recording_duration = 5  # seconds

    frame_sequence_dir = output_dir / "frame_sequence"
    frame_sequence_dir.mkdir(exist_ok=True)

    for i in range(fps * recording_duration):
        ret, frame = tools.camera.read()
        if ret and frame is not None:
            cv2.imwrite(str(frame_sequence_dir / f"frame_{i:04d}.jpg"), frame)
        else:
            logger.warning(f"Failed to capture frame {i}")
        time.sleep(1/fps)  # Wait appropriate time between frames
    
    time.sleep(5) # Wait for a few seconds to avoid turning off mid capture
    # 11. Turn off light ring
    logger.info("Turning off light ring...")
    try:
        arduino.send(PawduinoFunctions.CMD_WHITE_OFF) 
    except Exception as e:
        logger.warning(f"Could not control light ring: {e}")
        
    # 12. Raise pipette to safe position
    logger.info("Moving to safe position...")
    mill.move_to_safe_position()
    
    # Protocol complete
    logger.info("Solid handling protocol completed successfully")

except Exception as e:
    logger.error(f"Protocol failed: {e}", exc_info=True)
    print(f"An error occurred: {e}")

finally:
    # Cleanup
    try:
        # Release camera
        if hasattr(tools, 'camera') and tools.camera is not None:
            tools.camera.close()
            logger.info("Camera released")
        
        # Disconnect from hardware
        if 'mill' in locals():
            mill.disconnect()
            logger.info("Mill disconnected")
        
        print("Hardware disconnected. Protocol completed.")
        logger.info("Cleanup completed")
        
    except Exception as cleanup_error:
        print(f"Error during cleanup: {cleanup_error}")
        logger.error(f"Cleanup error: {cleanup_error}", exc_info=True)